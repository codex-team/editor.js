{"version":3,"sources":["webpack:///codex-editor.js","webpack:///webpack/bootstrap 76ee70c804ca96615825","webpack:///./codex.js","webpack:///./modules/core.js","webpack:///./modules/ui.js","webpack:///./modules/transport.js","webpack:///./modules/renderer.js","webpack:///./modules/saver.js","webpack:///./modules/content.js","webpack:///./modules/toolbar/toolbar.js","webpack:///./modules/toolbar/settings.js","webpack:///./modules/toolbar/inline.js","webpack:///./modules/toolbar/toolbox.js","webpack:///./modules/callbacks.js","webpack:///./modules/draw.js","webpack:///./modules/caret.js","webpack:///./modules/notifications.js","webpack:///./modules/parser.js","webpack:///./modules/sanitizer.js","webpack:///./~/html-janitor/src/html-janitor.js"],"names":["codex","modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","editor","version","init","core","ui","transport","renderer","saver","content","toolbar","callback","draw","caret","notifications","parser","sanitizer","settings","tools","textareaId","uploadImagesUrl","initialBlockPlugin","nodes","textarea","wrapper","inlineToolbar","buttons","actions","toolbox","plusButton","showSettingsButton","showTrashButton","blockSettings","pluginSettings","defaultSettings","toolbarButtons","redactor","state","jsonOutput","blocks","ArrayOfCachedData","inputs","start","userSettings","prepare","then","make","addTools","bindEvents","preparePlugins","makeBlocksFromData","saveInputs","catch","error","log","_typeof","Symbol","iterator","obj","constructor","prototype","Promise","resolve","reject","data","document","getElementById","undefined","Error","msg","type","arg","window","console","e","insertAfter","target","element","parentNode","insertBefore","nextSibling","nodeTypes","TAG","TEXT","COMMENT","keys","BACKSPACE","TAB","ENTER","SHIFT","CTRL","ALT","ESC","SPACE","LEFT","UP","DOWN","RIGHT","DELETE","META","isDomNode","el","nodeType","this","ajax","url","XMLHTTP","XMLHttpRequest","ActiveXObject","successFunction","params","async","success","test","encodeURIComponent","withCredentials","beforeSend","open","setRequestHeader","onreadystatechange","readyState","status","responseText","send","importScript","scriptPath","instanceName","instancePrefix","script","createElement","defer","onload","onerror","src","head","appendChild","className","BLOCK_CLASSNAME","BLOCK_CONTENT","BLOCK_STRETCHED","BLOCK_HIGHLIGHTED","BLOCK_IN_FEED_MODE","SETTINGS_ITEM","toolbarContent","blockButtons","alertsHolder","body","settingsButton","makeRemoveBlockButton","pluginsSettings","makeInlineToolbar","addDefaultSettings","container","inlineToolbarButtons","inlineToolbarActions","tool","toolName","toolButton","iconClassname","render","displayInToolbox","toolbarButton","addInlineToolbarTools","bold","icon","command","italic","underline","link","name","toolbarButtonInline","setInlineToolbarButtonBehaviour","addEventListener","globalKeydown","redactorKeyDown","globalKeyup","redactorClicked","plusButtonClicked","showSettingsButtonClicked","button","toolbarButtonClicked","resolve_","reject_","pluginName","plugin","queue","sequence","push","request","continue_","abort_","reduce","previousValue","currentValue","index","ahead_","away_","callPluginsPrepareMethod_","available","length","config","addBlockHandlers","block","blockKeydown","blockPasteCallback","inline","show","querySelectorAll","addInitialBlock","initialBlock","initialBlockType","setAttribute","insertBlock","workingNodeChanged","event","toolClicked","input","arguments","fileSelected","clearInput","files","formdData","FormData","append","selectAndUpload","args","click","xhr","items","appendBlocks","nodeSequence","appendNodeAtIndex","getNodeAsync","createBlockFromData","blockData","blocksList","cover","unavailableBlock","stretched","isStretched","saveBlocks","html","innerHTML","childNodes","makeQueue","getBlockData","makeFormDataFromBlocks","dataset","save","savedData","cacheId","output","blockContent","pluginsContent","validate","result","classList","contains","currentNode","editorAreaHightlighted","sync","getNodeFocused","focused","selection","getSelection","anchorNode","focusNode","parentElement","isFirstLevelBlock","parent","markBlock","add","clearMark","remove","getFirstLevelBlock","node","targetNode","replaceBlock","targetBlock","newBlock","replaceChild","needPlaceCaret","workingBlock","newBlockContent","blockType","composeNewBlock","currentInputIndex","getCurrentInputIndex","editableElement","querySelector","emptyText","createTextNode","set","move","showPlusButton","setTimeout","setToNextBlock","switchBlock","blockToReplace","newBlockComposed","getDeepestTextNodeFromPosition","position","text","blockChilds","textContent","trim","removeChild","lookingFromStart","getRange","getRangeAt","splitBlock","inputIndex","textBeforeCaret","textNodeBeforeCaret","textAfterCaret","textNodeAfterCaret","anchorNodeText","caretOffset","anchorOffset","currentBlock","substring","previousChilds","nextChilds","reachedCurrent","child","i","previousChildsLength","nextChildsLength","newNode","NEW_BLOCK_TYPE","mergeBlocks","targetInputIndex","targetInput","currentInputContent","paste","mutation","workingNode","allowedToPaste","sanitize","pasteTextContent","addedNodes","textNode","disconnect","cleaner","satinizer","Config","BASIC","clean","outerHTML","div","replaceWith","isLastNode","allChecked","allSiblingsEmpty_","sibling","wrapTextWithParagraphs","htmlString","paragraph","blockTyped","newWrapper","firstLevelBlocks","indexOf","tagName","cloneNode","defaultToolbarHeight","defaultOffset","opened","current","close","toggle","hidePlusButton","newYCoordinate","offsetTop","style","transform","Math","floor","hideRemoveActions","setting","toolType","makeSettings","settingsBlock","feedModeToggler","makeFeedModeToggler","isFeedModeActivated","updateFeedMode","removeBlockWrapper","settingButton","actionWrapper","confirmAction","cancelAction","removeButtonClicked","confirmRemovingRequest","cancelRemovingRequest","action","showRemoveActions","firstLevelBlocksCount","buttonsOpened","actionsOpened","wrappersOffset","storedSelection","showInlineToolbar","selectedText","getSelectionText","showButtons","getWrappersOffset","newCoordinateX","newCoordinateY","coords","getSelectionCoords","offsetHeight","x","left","y","scrollY","top","closeButtons","closeAction","createLinkAction","defaultToolAction","forEach","hightlight","offset","getOffset","_x","_y","isNaN","offsetLeft","clientLeft","clientTop","offsetParent","range","sel","createRange","collapse","boundingLeft","boundingTop","rangeCount","cloneRange","getClientRects","rect","toString","showActions","inlineToolbarAnchorInputKeydown_","keyCode","editable","restoreSelection","setAnchor","value","preventDefault","stopImmediatePropagation","clearRange","isActive","isLinkActive","saveSelection","inputForLink","focus","dataType","execCommand","containerEl","preSelectionRange","selectNodeContents","setEnd","startContainer","startOffset","end","savedSel","charIndex","setStart","nextCharIndex","nodeStack","foundStart","stop","pop","removeAllRanges","addRange","queryCommandState","setButtonHighlighted","removeButtonsHighLight","tag","leaf","currentTool","Object","barButtons","nextToolIndex","toolToSelect","visibleTool","appendCallback","UNREPLACEBLE_TOOLS","setToBlock","callbacks","enterKeyPressed","tabKeyPressed","enterKeyPressedOnRedactorZone","escapeKeyPressed","defaultKeyPressed","arrowKeyPressed","enterPressedOnBlock","contentEditable","saveCurrentInputIndex","isEnterPressedOnToolbar","enableLineBreaks","stopPropagation","shiftKey","currentSelection","currentSelectedNode","caretAtTheEndOfText","atTheEnd","isTextNodeHasParentBetweenContenteditable","islastNode","detectWhenClickedOnFirstLevelBlockArea","firstLevelBlock","indexOfLastInput","inputIsEmpty","currentNodeType","isInitialType","flag","blockRightOrDownArrowPressed","backspacePressed","blockLeftOrUpArrowPressed","focusedNodeHolder","focusedNode","editableElementIndex","lastChild","deepestTextnode","caretInLastChild","firstChild","caretInFirstChild","caretAtTheBeginning","setToPreviousBlock","selectionLength","endOffset","atStart","_blockPasteCallback","observer","MutationObserver","handleMutationsOnPaste","attributes","childList","characterData","subtree","observe","cleanData","fragment","clipboardData","getData","createDocumentFragment","lastNode","deleteContents","insertNode","setStartAfter","mutations","self","currentToolType","ceBlock","bar","placeholder","toggler","classname","toolIcon","toolTitle","properties","focusedNodeIndex","nodeToSet","childs","nextInput","emptyTextElement","lastChildNode","lengthOfLastChildNode","previousInput","pluginsRender","isFirstNode","isOffsetZero","errorThrown","errorMsg","message","notification","insertPastedContent","janitor","tags","a","href","rel","b","strong","em","span","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_RESULT__","root","factory","HTMLJanitor","tagDefinitions","validConfigValues","map","k","every","isBlockElement","blockElementNames","nodeName","isInlineElement","inlineElementNames","createTreeWalker","NodeFilter","SHOW_TEXT","SHOW_ELEMENT","SHOW_COMMENT","getAllowedAttrs","shouldRejectNode","allowedAttrs","shouldRejectAttr","attr","attrName","toLowerCase","sandbox","_sanitize","treeWalker","_sanitized","Node","TEXT_NODE","COMMENT_NODE","containsBlockElement","isInline","Array","some","isNotTopContainer","isNestedBlockElement","isInvalid","keepNestedBlockElements","removeAttribute","previousElementSibling","nextElementSibling"],"mappings":"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","file":"codex-editor.js","sourcesContent":["var codex = codex || {}; codex[\"editor\"] =\n/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t/**\n\t *\n\t * Codex Editor\n\t *\n\t * @author Codex Team\n\t */\n\t\n\tmodule.exports = function (editor) {\n\t\n\t    'use strict';\n\t\n\t    editor.version = (\"1.4.3\");\n\t\n\t    var init = function init() {\n\t\n\t        editor.core = __webpack_require__(1);\n\t        editor.ui = __webpack_require__(2);\n\t        editor.transport = __webpack_require__(3);\n\t        editor.renderer = __webpack_require__(4);\n\t        editor.saver = __webpack_require__(5);\n\t        editor.content = __webpack_require__(6);\n\t        editor.toolbar = __webpack_require__(7);\n\t        editor.callback = __webpack_require__(11);\n\t        editor.draw = __webpack_require__(12);\n\t        editor.caret = __webpack_require__(13);\n\t        editor.notifications = __webpack_require__(14);\n\t        editor.parser = __webpack_require__(15);\n\t        editor.sanitizer = __webpack_require__(16);\n\t    };\n\t\n\t    /**\n\t     * @public\n\t     *\n\t     * holds initial settings\n\t     */\n\t    editor.settings = {\n\t        tools: ['paragraph', 'header', 'picture', 'list', 'quote', 'code', 'twitter', 'instagram', 'smile'],\n\t        textareaId: 'codex-editor',\n\t        uploadImagesUrl: '/editor/transport/',\n\t\n\t        // Type of block showing on empty editor\n\t        initialBlockPlugin: 'paragraph'\n\t    };\n\t\n\t    /**\n\t     * public\n\t     *\n\t     * Static nodes\n\t     */\n\t    editor.nodes = {\n\t        textarea: null,\n\t        wrapper: null,\n\t        toolbar: null,\n\t        inlineToolbar: {\n\t            wrapper: null,\n\t            buttons: null,\n\t            actions: null\n\t        },\n\t        toolbox: null,\n\t        notifications: null,\n\t        plusButton: null,\n\t        showSettingsButton: null,\n\t        showTrashButton: null,\n\t        blockSettings: null,\n\t        pluginSettings: null,\n\t        defaultSettings: null,\n\t        toolbarButtons: {}, // { type : DomEl, ... }\n\t        redactor: null\n\t    };\n\t\n\t    /**\n\t     * @public\n\t     *\n\t     * Output state\n\t     */\n\t    editor.state = {\n\t        jsonOutput: [],\n\t        blocks: [],\n\t        ArrayOfCachedData: [],\n\t        inputs: []\n\t    };\n\t\n\t    /**\n\t    * @public\n\t    * Editor plugins\n\t    */\n\t    editor.tools = {};\n\t\n\t    /**\n\t     * Initialization\n\t     * @uses Promise cEditor.core.prepare\n\t     * @param {} userSettings are :\n\t     *          - tools [],\n\t     *          - textareaId String\n\t     *          ...\n\t     *\n\t     * Load user defined tools\n\t     * Tools must contain this important objects :\n\t     *  @param {String} type - this is a type of plugin. It can be used as plugin name\n\t     *  @param {String} iconClassname - this a icon in toolbar\n\t     *  @param {Object} make - what should plugin do, when it is clicked\n\t     *  @param {Object} appendCallback - callback after clicking\n\t     *  @param {Element} settings - what settings does it have\n\t     *  @param {Object} render - plugin get JSON, and should return HTML\n\t     *  @param {Object} save - plugin gets HTML content, returns JSON\n\t     *  @param {Boolean} displayInToolbox - will be displayed in toolbox. Default value is TRUE\n\t     *  @param {Boolean} enableLineBreaks - inserts new block or break lines. Default value is FALSE\n\t     *\n\t     * @example\n\t     *   -  type             : 'header',\n\t     *   -  iconClassname    : 'ce-icon-header',\n\t     *   -  make             : headerTool.make,\n\t     *   -  appendCallback   : headerTool.appendCallback,\n\t     *   -  settings         : headerTool.makeSettings(),\n\t     *   -  render           : headerTool.render,\n\t     *   -  save             : headerTool.save,\n\t     *   -  displayInToolbox : true,\n\t     *   -  enableLineBreaks : false\n\t     */\n\t    editor.start = function (userSettings) {\n\t\n\t        init();\n\t\n\t        editor.core.prepare(userSettings)\n\t\n\t        // If all ok, make UI, bind events and parse initial-content\n\t        .then(editor.ui.make).then(editor.ui.addTools).then(editor.ui.bindEvents).then(editor.ui.preparePlugins).then(editor.transport.prepare).then(editor.renderer.makeBlocksFromData).then(editor.ui.saveInputs).catch(function (error) {\n\t\n\t            editor.core.log('Initialization failed with error: %o', 'warn', error);\n\t        });\n\t    };\n\t\n\t    return editor;\n\t}({});\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\t/**\n\t * Codex Editor Core\n\t *\n\t * @author Codex Team\n\t * @version 1.1.2\n\t */\n\t\n\tvar editor = codex.editor;\n\t\n\tmodule.exports = function (core) {\n\t\n\t    /**\n\t     * @public\n\t     *\n\t     * Editor preparing method\n\t     * @return Promise\n\t     */\n\t    core.prepare = function (userSettings) {\n\t\n\t        return new Promise(function (resolve, reject) {\n\t\n\t            if (userSettings) {\n\t\n\t                editor.settings.tools = userSettings.tools || editor.settings.tools;\n\t            }\n\t\n\t            if (userSettings.data) {\n\t\n\t                editor.state.blocks = userSettings.data;\n\t            }\n\t\n\t            if (userSettings.initialBlockPlugin) {\n\t\n\t                editor.settings.initialBlockPlugin = userSettings.initialBlockPlugin;\n\t            }\n\t\n\t            if (userSettings.uploadImagesUrl) {\n\t\n\t                editor.settings.uploadImagesUrl = userSettings.uploadImagesUrl;\n\t            }\n\t\n\t            editor.nodes.textarea = document.getElementById(userSettings.textareaId || editor.settings.textareaId);\n\t\n\t            if (_typeof(editor.nodes.textarea) === undefined || editor.nodes.textarea === null) {\n\t\n\t                reject(Error(\"Textarea wasn't found by ID: #\" + userSettings.textareaId));\n\t            } else {\n\t\n\t                resolve();\n\t            }\n\t        });\n\t    };\n\t\n\t    /**\n\t     * Logging method\n\t     * @param type = ['log', 'info', 'warn']\n\t     */\n\t    core.log = function (msg, type, arg) {\n\t\n\t        type = type || 'log';\n\t\n\t        if (!arg) {\n\t\n\t            arg = msg || 'undefined';\n\t            msg = '[codex-editor]:      %o';\n\t        } else {\n\t\n\t            msg = '[codex-editor]:      ' + msg;\n\t        }\n\t\n\t        try {\n\t\n\t            if ('console' in window && window.console[type]) {\n\t\n\t                if (arg) window.console[type](msg, arg);else window.console[type](msg);\n\t            }\n\t        } catch (e) {}\n\t    };\n\t\n\t    /**\n\t     * @protected\n\t     *\n\t     * Helper for insert one element after another\n\t     */\n\t    core.insertAfter = function (target, element) {\n\t\n\t        target.parentNode.insertBefore(element, target.nextSibling);\n\t    };\n\t\n\t    /**\n\t     * @const\n\t     *\n\t     * Readable DOM-node types map\n\t     */\n\t    core.nodeTypes = {\n\t        TAG: 1,\n\t        TEXT: 3,\n\t        COMMENT: 8\n\t    };\n\t\n\t    /**\n\t     * @const\n\t     * Readable keys map\n\t     */\n\t    core.keys = { BACKSPACE: 8, TAB: 9, ENTER: 13, SHIFT: 16, CTRL: 17, ALT: 18, ESC: 27, SPACE: 32, LEFT: 37, UP: 38, DOWN: 40, RIGHT: 39, DELETE: 46, META: 91 };\n\t\n\t    /**\n\t     * @protected\n\t     *\n\t     * Check object for DOM node\n\t     */\n\t    core.isDomNode = function (el) {\n\t\n\t        return el && (typeof el === 'undefined' ? 'undefined' : _typeof(el)) === 'object' && el.nodeType && el.nodeType == this.nodeTypes.TAG;\n\t    };\n\t\n\t    /**\n\t     * Native Ajax\n\t     */\n\t    core.ajax = function (data) {\n\t\n\t        if (!data || !data.url) {\n\t\n\t            return;\n\t        }\n\t\n\t        var XMLHTTP = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject('Microsoft.XMLHTTP'),\n\t            successFunction = function successFunction() {},\n\t            params = '',\n\t            obj;\n\t\n\t        data.async = true;\n\t        data.type = data.type || 'GET';\n\t        data.data = data.data || '';\n\t        data['content-type'] = data['content-type'] || 'application/json; charset=utf-8';\n\t        successFunction = data.success || successFunction;\n\t\n\t        if (data.type == 'GET' && data.data) {\n\t\n\t            data.url = /\\?/.test(data.url) ? data.url + '&' + data.data : data.url + '?' + data.data;\n\t        } else {\n\t\n\t            for (obj in data.data) {\n\t\n\t                params += obj + '=' + encodeURIComponent(data.data[obj]) + '&';\n\t            }\n\t        }\n\t\n\t        if (data.withCredentials) {\n\t\n\t            XMLHTTP.withCredentials = true;\n\t        }\n\t\n\t        if (data.beforeSend && typeof data.beforeSend == 'function') {\n\t\n\t            data.beforeSend.call();\n\t        }\n\t\n\t        XMLHTTP.open(data.type, data.url, data.async);\n\t        XMLHTTP.setRequestHeader('X-Requested-With', 'XMLHttpRequest');\n\t        XMLHTTP.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');\n\t\n\t        XMLHTTP.onreadystatechange = function () {\n\t\n\t            if (XMLHTTP.readyState == 4 && XMLHTTP.status == 200) {\n\t\n\t                successFunction(XMLHTTP.responseText);\n\t            }\n\t        };\n\t\n\t        XMLHTTP.send(params);\n\t    };\n\t\n\t    /**\n\t    * Appends script to head of document\n\t    * @return Promise\n\t    */\n\t    core.importScript = function (scriptPath, instanceName) {\n\t\n\t        return new Promise(function (resolve, reject) {\n\t\n\t            var instancePrefix = 'cdx-script-';\n\t\n\t            var script = void 0;\n\t\n\t            /** Script is already loaded */\n\t            if (!instanceName) {\n\t\n\t                reject('Instance name is missed');\n\t            } else if (document.getElementById(instancePrefix + instanceName)) {\n\t\n\t                resolve(scriptPath);\n\t            }\n\t\n\t            script = document.createElement('SCRIPT');\n\t            script.async = true;\n\t            script.defer = true;\n\t            script.id = instancePrefix + instanceName;\n\t\n\t            script.onload = function () {\n\t\n\t                resolve(scriptPath);\n\t            };\n\t\n\t            script.onerror = function () {\n\t\n\t                reject(scriptPath);\n\t            };\n\t\n\t            script.src = scriptPath;\n\t            document.head.appendChild(script);\n\t        });\n\t    };\n\t\n\t    return core;\n\t}({});\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t/**\n\t * Codex Editor UI module\n\t *\n\t * @author Codex Team\n\t * @version 1.1\n\t */\n\t\n\tvar editor = codex.editor;\n\t\n\tmodule.exports = function (ui) {\n\t\n\t    /**\n\t     * Basic editor classnames\n\t     */\n\t    ui.className = {\n\t\n\t        /**\n\t         * @const {string} BLOCK_CLASSNAME - redactor blocks name\n\t         */\n\t        BLOCK_CLASSNAME: 'ce-block',\n\t\n\t        /**\n\t         * @const {String} wrapper for plugins content\n\t         */\n\t        BLOCK_CONTENT: 'ce-block__content',\n\t\n\t        /**\n\t         * @const {String} BLOCK_STRETCHED - makes block stretched\n\t         */\n\t        BLOCK_STRETCHED: 'ce-block--stretched',\n\t\n\t        /**\n\t         * @const {String} BLOCK_HIGHLIGHTED - adds background\n\t         */\n\t        BLOCK_HIGHLIGHTED: 'ce-block--focused',\n\t\n\t        /**\n\t         * @const {String} - highlights covered blocks\n\t         */\n\t        BLOCK_IN_FEED_MODE: 'ce-block--feed-mode',\n\t\n\t        /**\n\t         * @const {String} - for all default settings\n\t         */\n\t        SETTINGS_ITEM: 'ce-settings__item'\n\t\n\t    };\n\t\n\t    /**\n\t     * @protected\n\t     *\n\t     * Making main interface\n\t     */\n\t    ui.make = function () {\n\t\n\t        var wrapper, toolbar, toolbarContent, redactor, notifications, blockButtons, blockSettings, showSettingsButton, showTrashButton, toolbox, plusButton;\n\t\n\t        /** Make editor wrapper */\n\t        wrapper = editor.draw.wrapper();\n\t\n\t        /** Append editor wrapper after initial textarea */\n\t        editor.core.insertAfter(editor.nodes.textarea, wrapper);\n\t\n\t        /** Append block with notifications to the document */\n\t        notifications = editor.draw.alertsHolder();\n\t        editor.nodes.notifications = document.body.appendChild(notifications);\n\t\n\t        /** Make toolbar and content-editable redactor */\n\t        toolbar = editor.draw.toolbar();\n\t        toolbarContent = editor.draw.toolbarContent();\n\t        plusButton = editor.draw.plusButton();\n\t        showSettingsButton = editor.draw.settingsButton();\n\t        showTrashButton = editor.toolbar.settings.makeRemoveBlockButton();\n\t        blockSettings = editor.draw.blockSettings();\n\t        blockButtons = editor.draw.blockButtons();\n\t        toolbox = editor.draw.toolbox();\n\t        redactor = editor.draw.redactor();\n\t\n\t        /** settings */\n\t        var defaultSettings = editor.draw.defaultSettings(),\n\t            pluginSettings = editor.draw.pluginsSettings();\n\t\n\t        /** Add default and plugins settings */\n\t        blockSettings.appendChild(pluginSettings);\n\t        blockSettings.appendChild(defaultSettings);\n\t\n\t        /** Make blocks buttons\n\t         * This block contains settings button and remove block button\n\t         */\n\t        blockButtons.appendChild(showSettingsButton);\n\t        blockButtons.appendChild(showTrashButton);\n\t        blockButtons.appendChild(blockSettings);\n\t\n\t        /** Append plus button */\n\t        toolbarContent.appendChild(plusButton);\n\t\n\t        /** Appending toolbar tools */\n\t        toolbarContent.appendChild(toolbox);\n\t\n\t        /** Appending first-level block buttons */\n\t        toolbar.appendChild(blockButtons);\n\t\n\t        /** Append toolbarContent to toolbar */\n\t        toolbar.appendChild(toolbarContent);\n\t\n\t        wrapper.appendChild(toolbar);\n\t\n\t        wrapper.appendChild(redactor);\n\t\n\t        /** Save created ui-elements to static nodes state */\n\t        editor.nodes.wrapper = wrapper;\n\t        editor.nodes.toolbar = toolbar;\n\t        editor.nodes.plusButton = plusButton;\n\t        editor.nodes.toolbox = toolbox;\n\t        editor.nodes.blockSettings = blockSettings;\n\t        editor.nodes.pluginSettings = pluginSettings;\n\t        editor.nodes.defaultSettings = defaultSettings;\n\t        editor.nodes.showSettingsButton = showSettingsButton;\n\t        editor.nodes.showTrashButton = showTrashButton;\n\t\n\t        editor.nodes.redactor = redactor;\n\t\n\t        /** Make container for inline toolbar */\n\t        editor.ui.makeInlineToolbar();\n\t\n\t        /** fill in default settings */\n\t        editor.toolbar.settings.addDefaultSettings();\n\t    };\n\t\n\t    ui.makeInlineToolbar = function () {\n\t\n\t        var container = editor.draw.inlineToolbar();\n\t\n\t        /** Append to redactor new inline block */\n\t        editor.nodes.inlineToolbar.wrapper = container;\n\t\n\t        /** Draw toolbar buttons */\n\t        editor.nodes.inlineToolbar.buttons = editor.draw.inlineToolbarButtons();\n\t\n\t        /** Buttons action or settings */\n\t        editor.nodes.inlineToolbar.actions = editor.draw.inlineToolbarActions();\n\t\n\t        /** Append to inline toolbar buttons as part of it */\n\t        editor.nodes.inlineToolbar.wrapper.appendChild(editor.nodes.inlineToolbar.buttons);\n\t        editor.nodes.inlineToolbar.wrapper.appendChild(editor.nodes.inlineToolbar.actions);\n\t\n\t        editor.nodes.wrapper.appendChild(editor.nodes.inlineToolbar.wrapper);\n\t    };\n\t\n\t    /**\n\t     * @private\n\t     * Append tools passed in editor.tools\n\t     */\n\t    ui.addTools = function () {\n\t\n\t        var tool, toolName, toolButton;\n\t\n\t        for (toolName in editor.settings.tools) {\n\t\n\t            tool = editor.settings.tools[toolName];\n\t\n\t            editor.tools[toolName] = tool;\n\t\n\t            if (!tool.iconClassname) {\n\t\n\t                editor.core.log('Toolbar icon classname missed. Tool %o skipped', 'warn', toolName);\n\t                continue;\n\t            }\n\t\n\t            if (typeof tool.render != 'function') {\n\t\n\t                editor.core.log('render method missed. Tool %o skipped', 'warn', toolName);\n\t                continue;\n\t            }\n\t\n\t            if (!tool.displayInToolbox) {\n\t\n\t                continue;\n\t            } else {\n\t\n\t                /** if tools is for toolbox */\n\t                toolButton = editor.draw.toolbarButton(toolName, tool.iconClassname);\n\t\n\t                editor.nodes.toolbox.appendChild(toolButton);\n\t\n\t                editor.nodes.toolbarButtons[toolName] = toolButton;\n\t            }\n\t        }\n\t\n\t        /**\n\t         * Add inline toolbar tools\n\t         */\n\t        editor.ui.addInlineToolbarTools();\n\t    };\n\t\n\t    ui.addInlineToolbarTools = function () {\n\t\n\t        var tools = {\n\t\n\t            bold: {\n\t                icon: 'ce-icon-bold',\n\t                command: 'bold'\n\t            },\n\t\n\t            italic: {\n\t                icon: 'ce-icon-italic',\n\t                command: 'italic'\n\t            },\n\t\n\t            underline: {\n\t                icon: 'ce-icon-underline',\n\t                command: 'underline'\n\t            },\n\t\n\t            link: {\n\t                icon: 'ce-icon-link',\n\t                command: 'createLink'\n\t            }\n\t        };\n\t\n\t        var toolButton, tool;\n\t\n\t        for (var name in tools) {\n\t\n\t            tool = tools[name];\n\t\n\t            toolButton = editor.draw.toolbarButtonInline(name, tool.icon);\n\t\n\t            editor.nodes.inlineToolbar.buttons.appendChild(toolButton);\n\t            /**\n\t             * Add callbacks to this buttons\n\t             */\n\t            editor.ui.setInlineToolbarButtonBehaviour(toolButton, tool.command);\n\t        }\n\t    };\n\t\n\t    /**\n\t     * @private\n\t     * Bind editor UI events\n\t     */\n\t    ui.bindEvents = function () {\n\t\n\t        editor.core.log('ui.bindEvents fired', 'info');\n\t\n\t        // window.addEventListener('error', function (errorMsg, url, lineNumber) {\n\t        //     editor.notifications.errorThrown(errorMsg, event);\n\t        // }, false );\n\t\n\t        /** All keydowns on Document */\n\t        document.addEventListener('keydown', editor.callback.globalKeydown, false);\n\t\n\t        /** All keydowns on Redactor zone */\n\t        editor.nodes.redactor.addEventListener('keydown', editor.callback.redactorKeyDown, false);\n\t\n\t        /** All keydowns on Document */\n\t        document.addEventListener('keyup', editor.callback.globalKeyup, false);\n\t\n\t        /**\n\t         * Mouse click to radactor\n\t         */\n\t        editor.nodes.redactor.addEventListener('click', editor.callback.redactorClicked, false);\n\t\n\t        /**\n\t         * Clicks to the Plus button\n\t         */\n\t        editor.nodes.plusButton.addEventListener('click', editor.callback.plusButtonClicked, false);\n\t\n\t        /**\n\t         * Clicks to SETTINGS button in toolbar\n\t         */\n\t        editor.nodes.showSettingsButton.addEventListener('click', editor.callback.showSettingsButtonClicked, false);\n\t\n\t        /**\n\t         *  @deprecated ( but now in use for syncronization );\n\t         *  Any redactor changes: keyboard input, mouse cut/paste, drag-n-drop text\n\t         */\n\t        // editor.nodes.redactor.addEventListener('input', editor.callback.redactorInputEvent, false );\n\t\n\t        /** Bind click listeners on toolbar buttons */\n\t        for (var button in editor.nodes.toolbarButtons) {\n\t\n\t            editor.nodes.toolbarButtons[button].addEventListener('click', editor.callback.toolbarButtonClicked, false);\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Initialize plugins before using\n\t     * Ex. Load scripts or call some internal methods\n\t     * @return Promise\n\t     */\n\t    ui.preparePlugins = function () {\n\t\n\t        return new Promise(function (resolve_, reject_) {\n\t\n\t            var pluginName = void 0,\n\t                plugin = void 0,\n\t                queue = [],\n\t                sequence = void 0;\n\t\n\t            for (pluginName in editor.tools) {\n\t\n\t                plugin = editor.tools[pluginName];\n\t\n\t                if (plugin.prepare && typeof plugin.prepare != 'function' || !plugin.prepare) {\n\t\n\t                    continue;\n\t                }\n\t\n\t                queue.push(plugin);\n\t            }\n\t\n\t            /** Make a sequence from blocks that have prepare method */\n\t            sequence = Promise.resolve();\n\t\n\t            sequence.then(function () {\n\t\n\t                return queue;\n\t            }).then(function (request) {\n\t\n\t                return new Promise(function (continue_, abort_) {\n\t\n\t                    request.reduce(function (previousValue, currentValue, index) {\n\t\n\t                        return previousValue.then(function () {\n\t\n\t                            return new Promise(function (ahead_, away_) {\n\t\n\t                                callPluginsPrepareMethod_(currentValue).then(ahead_).then(function () {\n\t\n\t                                    currentValue.available = true;\n\t\n\t                                    if (index == request.length - 1) {\n\t\n\t                                        continue_();\n\t                                    }\n\t                                }).catch(function () {\n\t\n\t                                    editor.core.log('Plugin was not loaded', 'warn', currentValue);\n\t                                    currentValue.available = false;\n\t\n\t                                    /** Go ahead even some plugin has problems */\n\t                                    ahead_();\n\t\n\t                                    /** If last plugin has problems then just ignore and continue */\n\t                                    if (index == request.length - 1) {\n\t\n\t                                        continue_();\n\t                                    }\n\t                                });\n\t                            });\n\t                        });\n\t                    }, Promise.resolve());\n\t                });\n\t            }).then(function () {\n\t\n\t                editor.core.log('Basic functionality initialized', 'info');\n\t                resolve_();\n\t            }).catch(function (error) {\n\t\n\t                reject_(error);\n\t            });\n\t        });\n\t    };\n\t\n\t    var callPluginsPrepareMethod_ = function callPluginsPrepareMethod_(plugin) {\n\t\n\t        return plugin.prepare(plugin.config || {});\n\t    };\n\t\n\t    ui.addBlockHandlers = function (block) {\n\t\n\t        if (!block) return;\n\t\n\t        /**\n\t         * Block keydowns\n\t         */\n\t        block.addEventListener('keydown', editor.callback.blockKeydown, false);\n\t\n\t        /**\n\t         * Pasting content from another source\n\t         * We have two type of sanitization\n\t         * First - uses deep-first search algorithm to get sub nodes,\n\t         * sanitizes whole Block_content and replaces cleared nodes\n\t         * This method is deprecated\n\t         * Method is used in editor.callback.blockPaste(event)\n\t         *\n\t         * Secont - uses Mutation observer.\n\t         * Observer \"observe\" DOM changes and send changings to callback.\n\t         * Callback gets changed node, not whole Block_content.\n\t         * Inserted or changed node, which we've gotten have been cleared and replaced with diry node\n\t         *\n\t         * Method is used in editor.callback.blockPasteViaSanitize(event)\n\t         *\n\t         * @uses html-janitor\n\t         * @example editor.callback.blockPasteViaSanitize(event), the second method.\n\t         *\n\t         */\n\t        block.addEventListener('paste', editor.callback.blockPasteCallback, false);\n\t\n\t        block.addEventListener('mouseup', editor.toolbar.inline.show, false);\n\t    };\n\t\n\t    /** getting all contenteditable elements */\n\t    ui.saveInputs = function () {\n\t\n\t        var redactor = editor.nodes.redactor;\n\t\n\t        /** Save all inputs in global variable state */\n\t        editor.state.inputs = redactor.querySelectorAll('[contenteditable], input');\n\t    };\n\t\n\t    /**\n\t     * Adds first initial block on empty redactor\n\t     */\n\t    ui.addInitialBlock = function () {\n\t\n\t        var initialBlockType = editor.settings.initialBlockPlugin,\n\t            initialBlock;\n\t\n\t        if (!editor.tools[initialBlockType]) {\n\t\n\t            editor.core.log('Plugin %o was not implemented and can\\'t be used as initial block', 'warn', initialBlockType);\n\t            return;\n\t        }\n\t\n\t        initialBlock = editor.tools[initialBlockType].render();\n\t\n\t        initialBlock.setAttribute('data-placeholder', '  ...');\n\t\n\t        editor.content.insertBlock({\n\t            type: initialBlockType,\n\t            block: initialBlock\n\t        });\n\t\n\t        editor.content.workingNodeChanged(initialBlock);\n\t    };\n\t\n\t    ui.setInlineToolbarButtonBehaviour = function (button, type) {\n\t\n\t        button.addEventListener('mousedown', function (event) {\n\t\n\t            editor.toolbar.inline.toolClicked(event, type);\n\t        }, false);\n\t    };\n\t\n\t    return ui;\n\t}({});\n\n/***/ },\n/* 3 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t/**\n\t *\n\t * Codex.Editor Transport Module\n\t *\n\t * @author Codex Team\n\t * @version 1.0\n\t */\n\tvar editor = codex.editor;\n\t\n\tmodule.exports = function (transport) {\n\t\n\t    transport.input = null;\n\t\n\t    /**\n\t     * @property {Object} arguments - keep plugin settings and defined callbacks\n\t     */\n\t    transport.arguments = null;\n\t\n\t    transport.prepare = function () {\n\t\n\t        var input = document.createElement('INPUT');\n\t\n\t        input.type = 'file';\n\t        input.addEventListener('change', editor.transport.fileSelected);\n\t\n\t        editor.transport.input = input;\n\t    };\n\t\n\t    /** Clear input when files is uploaded */\n\t    transport.clearInput = function () {\n\t\n\t        /** Remove old input */\n\t        this.input = null;\n\t\n\t        /** Prepare new one */\n\t        this.prepare();\n\t    };\n\t\n\t    /**\n\t     * Callback for file selection\n\t     * @param {Event} event\n\t     */\n\t    transport.fileSelected = function () {\n\t\n\t        var input = this,\n\t            files = input.files,\n\t            formdData = new FormData();\n\t\n\t        formdData.append('files', files[0], files[0].name);\n\t\n\t        editor.transport.ajax({\n\t            data: formdData,\n\t            beforeSend: editor.transport.arguments.beforeSend,\n\t            success: editor.transport.arguments.success,\n\t            error: editor.transport.arguments.error\n\t        });\n\t    };\n\t\n\t    /**\n\t     * Use plugin callbacks\n\t     * @protected\n\t     */\n\t    transport.selectAndUpload = function (args) {\n\t\n\t        this.arguments = args;\n\t        this.input.click();\n\t    };\n\t\n\t    /**\n\t     * Ajax requests module\n\t     * @todo use core.ajax\n\t     */\n\t    transport.ajax = function (params) {\n\t\n\t        var xhr = new XMLHttpRequest(),\n\t            beforeSend = typeof params.beforeSend == 'function' ? params.beforeSend : function () {},\n\t            success = typeof params.success == 'function' ? params.success : function () {},\n\t            error = typeof params.error == 'function' ? params.error : function () {};\n\t\n\t        beforeSend();\n\t\n\t        xhr.open('POST', editor.settings.uploadImagesUrl, true);\n\t\n\t        xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');\n\t\n\t        xhr.onload = function () {\n\t\n\t            if (xhr.status === 200) {\n\t\n\t                success(xhr.responseText);\n\t            } else {\n\t\n\t                editor.core.log('request error: %o', xhr);\n\t                error();\n\t            }\n\t        };\n\t\n\t        xhr.send(params.data);\n\t        this.clearInput();\n\t    };\n\t\n\t    return transport;\n\t}({});\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t/**\n\t * Codex Editor Renderer Module\n\t *\n\t * @author Codex Team\n\t * @version 1.0\n\t */\n\t\n\tvar editor = codex.editor;\n\t\n\tmodule.exports = function (renderer) {\n\t\n\t    /**\n\t     * Asyncronously parses input JSON to redactor blocks\n\t     */\n\t    renderer.makeBlocksFromData = function () {\n\t\n\t        /**\n\t         * If redactor is empty, add first paragraph to start writing\n\t         */\n\t        if (!editor.state.blocks.items.length) {\n\t\n\t            editor.ui.addInitialBlock();\n\t            return;\n\t        }\n\t\n\t        Promise.resolve()\n\t\n\t        /** First, get JSON from state */\n\t        .then(function () {\n\t\n\t            return editor.state.blocks;\n\t        })\n\t\n\t        /** Then, start to iterate they */\n\t        .then(editor.renderer.appendBlocks)\n\t\n\t        /** Write log if something goes wrong */\n\t        .catch(function (error) {\n\t\n\t            editor.core.log('Error while parsing JSON: %o', 'error', error);\n\t        });\n\t    };\n\t\n\t    /**\n\t     * Parses JSON to blocks\n\t     * @param {object} data\n\t     * @return Primise -> nodeList\n\t     */\n\t    renderer.appendBlocks = function (data) {\n\t\n\t        var blocks = data.items;\n\t\n\t        /**\n\t         * Sequence of one-by-one blocks appending\n\t         * Uses to save blocks order after async-handler\n\t         */\n\t        var nodeSequence = Promise.resolve();\n\t\n\t        for (var index = 0; index < blocks.length; index++) {\n\t\n\t            /** Add node to sequence at specified index */\n\t            editor.renderer.appendNodeAtIndex(nodeSequence, blocks, index);\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Append node at specified index\n\t     */\n\t    renderer.appendNodeAtIndex = function (nodeSequence, blocks, index) {\n\t\n\t        /** We need to append node to sequence */\n\t        nodeSequence\n\t\n\t        /** first, get node async-aware */\n\t        .then(function () {\n\t\n\t            return editor.renderer.getNodeAsync(blocks, index);\n\t        })\n\t\n\t        /**\n\t         * second, compose editor-block from JSON object\n\t         */\n\t        .then(editor.renderer.createBlockFromData)\n\t\n\t        /**\n\t         * now insert block to redactor\n\t         */\n\t        .then(function (blockData) {\n\t\n\t            /**\n\t             * blockData has 'block', 'type' and 'stretched' information\n\t             */\n\t            editor.content.insertBlock(blockData);\n\t\n\t            /** Pass created block to next step */\n\t            return blockData.block;\n\t        })\n\t\n\t        /** Log if something wrong with node */\n\t        .catch(function (error) {\n\t\n\t            editor.core.log('Node skipped while parsing because %o', 'error', error);\n\t        });\n\t    };\n\t\n\t    /**\n\t     * Asynchronously returns block data from blocksList by index\n\t     * @return Promise to node\n\t     */\n\t    renderer.getNodeAsync = function (blocksList, index) {\n\t\n\t        return Promise.resolve().then(function () {\n\t\n\t            return blocksList[index];\n\t        });\n\t    };\n\t\n\t    /**\n\t     * Creates editor block by JSON-data\n\t     *\n\t     * @uses render method of each plugin\n\t     *\n\t     * @param {object} blockData looks like\n\t     *                            { header : {\n\t     *                                            text: '',\n\t     *                                            type: 'H3', ...\n\t     *                                        }\n\t     *                            }\n\t     * @return {object} with type and Element\n\t     */\n\t    renderer.createBlockFromData = function (blockData) {\n\t\n\t        /** New parser */\n\t        var block,\n\t            ArrayOfCachedData = codex.editor.state.ArrayOfCachedData,\n\t            pluginName = blockData.type,\n\t            cover = blockData.cover;\n\t\n\t        /** Get first key of object that stores plugin name */\n\t        // for (var pluginName in blockData) break;\n\t\n\t        /** Check for plugin existance */\n\t        if (!editor.tools[pluginName]) {\n\t\n\t            throw Error('Plugin \\xAB' + pluginName + '\\xBB not found');\n\t        }\n\t\n\t        /** Check for plugin having render method */\n\t        if (typeof editor.tools[pluginName].render != 'function') {\n\t\n\t            throw Error('Plugin \\xAB' + pluginName + '\\xBB must have \\xABrender\\xBB method');\n\t        }\n\t\n\t        if (editor.tools[pluginName].available === false) {\n\t\n\t            block = editor.draw.unavailableBlock(ArrayOfCachedData.length);\n\t\n\t            /** Save to restore data of unavailable plugins */\n\t            ArrayOfCachedData.push(blockData.data);\n\t        } else {\n\t\n\t            /** New Parser */\n\t            block = editor.tools[pluginName].render(blockData.data);\n\t        }\n\t\n\t        /** is first-level block stretched */\n\t        var stretched = editor.tools[pluginName].isStretched || false;\n\t\n\t        /** Retrun type and block */\n\t        return {\n\t            type: pluginName,\n\t            block: block,\n\t            stretched: stretched,\n\t            cover: cover\n\t        };\n\t    };\n\t\n\t    return renderer;\n\t}({});\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t/**\n\t * Codex Editor Saver\n\t *\n\t * @author Codex Team\n\t * @version 1.0.2\n\t */\n\t\n\tvar editor = codex.editor;\n\t\n\tmodule.exports = function (saver) {\n\t\n\t    /**\n\t     * Saves blocks\n\t     * @private\n\t     */\n\t    saver.saveBlocks = function () {\n\t\n\t        /** Save html content of redactor to memory */\n\t        editor.state.html = editor.nodes.redactor.innerHTML;\n\t\n\t        /** Empty jsonOutput state */\n\t        editor.state.jsonOutput = [];\n\t\n\t        Promise.resolve().then(function () {\n\t\n\t            return editor.nodes.redactor.childNodes;\n\t        })\n\t        /** Making a sequence from separate blocks */\n\t        .then(editor.saver.makeQueue).then(function () {\n\t            // editor.nodes.textarea.innerHTML = editor.state.html;\n\t        }).catch(function (error) {\n\t\n\t            editor.core.log(error);\n\t        });\n\t    };\n\t\n\t    saver.makeQueue = function (blocks) {\n\t\n\t        var queue = Promise.resolve();\n\t\n\t        for (var index = 0; index < blocks.length; index++) {\n\t\n\t            /** Add node to sequence at specified index */\n\t            editor.saver.getBlockData(queue, blocks, index);\n\t        }\n\t    };\n\t\n\t    /** Gets every block and makes From Data */\n\t    saver.getBlockData = function (queue, blocks, index) {\n\t\n\t        queue.then(function () {\n\t\n\t            return editor.saver.getNodeAsync(blocks, index);\n\t        }).then(editor.saver.makeFormDataFromBlocks);\n\t    };\n\t\n\t    /**\n\t     * Asynchronously returns block data from blocksList by index\n\t     * @return Promise to node\n\t     */\n\t    saver.getNodeAsync = function (blocksList, index) {\n\t\n\t        return Promise.resolve().then(function () {\n\t\n\t            return blocksList[index];\n\t        });\n\t    };\n\t\n\t    saver.makeFormDataFromBlocks = function (block) {\n\t\n\t        var pluginName = block.dataset.tool;\n\t\n\t        /** Check for plugin existance */\n\t        if (!editor.tools[pluginName]) {\n\t\n\t            throw Error('Plugin \\xAB' + pluginName + '\\xBB not found');\n\t        }\n\t\n\t        /** Check for plugin having render method */\n\t        if (typeof editor.tools[pluginName].save != 'function') {\n\t\n\t            throw Error('Plugin \\xAB' + pluginName + '\\xBB must have save method');\n\t        }\n\t\n\t        /** Result saver */\n\t        var blockContent = block.childNodes[0],\n\t            pluginsContent = blockContent.childNodes[0],\n\t            savedData,\n\t            ArrayOfCachedData = codex.editor.state.ArrayOfCachedData,\n\t            cacheId,\n\t            output;\n\t\n\t        /** If plugin wasn't available then return data from cache */\n\t        if (editor.tools[pluginName].available === false) {\n\t\n\t            cacheId = pluginsContent.dataset.cacheId;\n\t            savedData = ArrayOfCachedData[cacheId];\n\t        } else {\n\t\n\t            savedData = editor.tools[pluginName].save(pluginsContent);\n\t\n\t            if (editor.tools[pluginName].validate) {\n\t\n\t                var result = editor.tools[pluginName].validate(savedData);\n\t\n\t                /**\n\t                 * Do not allow invalid data\n\t                 */\n\t                if (!result) return;\n\t            }\n\t        }\n\t\n\t        output = {\n\t            type: pluginName,\n\t            data: savedData\n\t        };\n\t\n\t        /** Marks Blocks that will be in main page */\n\t        output.cover = block.classList.contains(editor.ui.className.BLOCK_IN_FEED_MODE);\n\t\n\t        editor.state.jsonOutput.push(output);\n\t    };\n\t\n\t    return saver;\n\t}({});\n\n/***/ },\n/* 6 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t/**\n\t * Codex Editor Content Module\n\t * Works with DOM\n\t *\n\t * @author Codex Team\n\t * @version 1.3.11\n\t */\n\tvar editor = codex.editor;\n\t\n\tmodule.exports = function (content) {\n\t\n\t    /**\n\t     * Links to current active block\n\t     * @type {null | Element}\n\t     */\n\t    content.currentNode = null;\n\t\n\t    /**\n\t     * clicked in redactor area\n\t     * @type {null | Boolean}\n\t     */\n\t    content.editorAreaHightlighted = null;\n\t\n\t    /**\n\t     * Synchronizes redactor with original textarea\n\t     */\n\t    content.sync = function () {\n\t\n\t        editor.core.log('syncing...');\n\t\n\t        /**\n\t         * Save redactor content to editor.state\n\t         */\n\t        editor.state.html = editor.nodes.redactor.innerHTML;\n\t    };\n\t\n\t    /**\n\t     * @deprecated\n\t     */\n\t    content.getNodeFocused = function () {\n\t\n\t        var selection = window.getSelection(),\n\t            focused;\n\t\n\t        if (selection.anchorNode === null) {\n\t\n\t            return null;\n\t        }\n\t\n\t        if (selection.anchorNode.nodeType == editor.core.nodeTypes.TAG) {\n\t\n\t            focused = selection.anchorNode;\n\t        } else {\n\t\n\t            focused = selection.focusNode.parentElement;\n\t        }\n\t\n\t        if (!editor.parser.isFirstLevelBlock(focused)) {\n\t\n\t            /** Iterate with parent nodes to find first-level*/\n\t            var parent = focused.parentNode;\n\t\n\t            while (parent && !editor.parser.isFirstLevelBlock(parent)) {\n\t\n\t                parent = parent.parentNode;\n\t            }\n\t\n\t            focused = parent;\n\t        }\n\t\n\t        if (focused != editor.nodes.redactor) {\n\t\n\t            return focused;\n\t        }\n\t\n\t        return null;\n\t    };\n\t\n\t    /**\n\t     * Appends background to the block\n\t     */\n\t    content.markBlock = function () {\n\t\n\t        editor.content.currentNode.classList.add(editor.ui.className.BLOCK_HIGHLIGHTED);\n\t    };\n\t\n\t    /**\n\t     * Clear background\n\t     */\n\t    content.clearMark = function () {\n\t\n\t        if (editor.content.currentNode) {\n\t\n\t            editor.content.currentNode.classList.remove(editor.ui.className.BLOCK_HIGHLIGHTED);\n\t        }\n\t    };\n\t\n\t    /**\n\t     * @private\n\t     *\n\t     * Finds first-level block\n\t     * @param {Element} node - selected or clicked in redactors area node\n\t     */\n\t    content.getFirstLevelBlock = function (node) {\n\t\n\t        if (!editor.core.isDomNode(node)) {\n\t\n\t            node = node.parentNode;\n\t        }\n\t\n\t        if (node === editor.nodes.redactor || node === document.body) {\n\t\n\t            return null;\n\t        } else {\n\t\n\t            while (!node.classList.contains(editor.ui.className.BLOCK_CLASSNAME)) {\n\t\n\t                node = node.parentNode;\n\t            }\n\t\n\t            return node;\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Trigger this event when working node changed\n\t     * @param {Element} targetNode - first-level of this node will be current\n\t     * If targetNode is first-level then we set it as current else we look for parents to find first-level\n\t     */\n\t    content.workingNodeChanged = function (targetNode) {\n\t\n\t        /** Clear background from previous marked block before we change */\n\t        editor.content.clearMark();\n\t\n\t        if (!targetNode) {\n\t\n\t            return;\n\t        }\n\t\n\t        this.currentNode = this.getFirstLevelBlock(targetNode);\n\t    };\n\t\n\t    /**\n\t     * Replaces one redactor block with another\n\t     * @protected\n\t     * @param {Element} targetBlock - block to replace. Mostly currentNode.\n\t     * @param {Element} newBlock\n\t     * @param {string} newBlockType - type of new block; we need to store it to data-attribute\n\t     *\n\t     * [!] Function does not saves old block content.\n\t     *     You can get it manually and pass with newBlock.innerHTML\n\t     */\n\t    content.replaceBlock = function (targetBlock, newBlock) {\n\t\n\t        if (!targetBlock || !newBlock) {\n\t\n\t            editor.core.log('replaceBlock: missed params');\n\t            return;\n\t        }\n\t\n\t        /** If target-block is not a frist-level block, then we iterate parents to find it */\n\t        while (!targetBlock.classList.contains(editor.ui.className.BLOCK_CLASSNAME)) {\n\t\n\t            targetBlock = targetBlock.parentNode;\n\t        }\n\t\n\t        /**\n\t         * Check is this block was in feed\n\t         * If true, than set switched block also covered\n\t         */\n\t        if (targetBlock.classList.contains(editor.ui.className.BLOCK_IN_FEED_MODE)) {\n\t\n\t            newBlock.classList.add(editor.ui.className.BLOCK_IN_FEED_MODE);\n\t        }\n\t\n\t        /** Replacing */\n\t        editor.nodes.redactor.replaceChild(newBlock, targetBlock);\n\t\n\t        /**\n\t         * Set new node as current\n\t         */\n\t        editor.content.workingNodeChanged(newBlock);\n\t\n\t        /**\n\t         * Add block handlers\n\t         */\n\t        editor.ui.addBlockHandlers(newBlock);\n\t\n\t        /**\n\t         * Save changes\n\t         */\n\t        editor.ui.saveInputs();\n\t    };\n\t\n\t    /**\n\t     * @private\n\t     *\n\t     * Inserts new block to redactor\n\t     * Wrapps block into a DIV with BLOCK_CLASSNAME class\n\t     *\n\t     * @param blockData          {object}\n\t     * @param blockData.block    {Element}   element with block content\n\t     * @param blockData.type     {string}    block plugin\n\t     * @param needPlaceCaret     {bool}      pass true to set caret in new block\n\t     *\n\t     */\n\t    content.insertBlock = function (blockData, needPlaceCaret) {\n\t\n\t        var workingBlock = editor.content.currentNode,\n\t            newBlockContent = blockData.block,\n\t            blockType = blockData.type,\n\t            cover = blockData.cover,\n\t            isStretched = blockData.stretched;\n\t\n\t        var newBlock = editor.content.composeNewBlock(newBlockContent, blockType, isStretched);\n\t\n\t        if (cover === true) {\n\t\n\t            newBlock.classList.add(editor.ui.className.BLOCK_IN_FEED_MODE);\n\t        }\n\t\n\t        if (workingBlock) {\n\t\n\t            editor.core.insertAfter(workingBlock, newBlock);\n\t        } else {\n\t\n\t            /**\n\t             * If redactor is empty, append as first child\n\t             */\n\t            editor.nodes.redactor.appendChild(newBlock);\n\t        }\n\t\n\t        /**\n\t         * Block handler\n\t         */\n\t        editor.ui.addBlockHandlers(newBlock);\n\t\n\t        /**\n\t         * Set new node as current\n\t         */\n\t        editor.content.workingNodeChanged(newBlock);\n\t\n\t        /**\n\t         * Save changes\n\t         */\n\t        editor.ui.saveInputs();\n\t\n\t        if (needPlaceCaret) {\n\t\n\t            /**\n\t             * If we don't know input index then we set default value -1\n\t             */\n\t            var currentInputIndex = editor.caret.getCurrentInputIndex() || -1;\n\t\n\t            if (currentInputIndex == -1) {\n\t\n\t                var editableElement = newBlock.querySelector('[contenteditable]'),\n\t                    emptyText = document.createTextNode('');\n\t\n\t                editableElement.appendChild(emptyText);\n\t                editor.caret.set(editableElement, 0, 0);\n\t\n\t                editor.toolbar.move();\n\t                editor.toolbar.showPlusButton();\n\t            } else {\n\t\n\t                if (currentInputIndex === editor.state.inputs.length - 1) return;\n\t\n\t                /** Timeout for browsers execution */\n\t                window.setTimeout(function () {\n\t\n\t                    /** Setting to the new input */\n\t                    editor.caret.setToNextBlock(currentInputIndex);\n\t                    editor.toolbar.move();\n\t                    editor.toolbar.open();\n\t                }, 10);\n\t            }\n\t        }\n\t\n\t        /**\n\t         * Block is inserted, wait for new click that defined focusing on editors area\n\t         * @type {boolean}\n\t         */\n\t        content.editorAreaHightlighted = false;\n\t    };\n\t\n\t    /**\n\t     * Replaces blocks with saving content\n\t     * @protected\n\t     * @param {Element} noteToReplace\n\t     * @param {Element} newNode\n\t     * @param {Element} blockType\n\t     */\n\t    content.switchBlock = function (blockToReplace, newBlock, tool) {\n\t\n\t        var newBlockComposed = editor.content.composeNewBlock(newBlock, tool);\n\t\n\t        /** Replacing */\n\t        editor.content.replaceBlock(blockToReplace, newBlockComposed);\n\t\n\t        /** Save new Inputs when block is changed */\n\t        editor.ui.saveInputs();\n\t    };\n\t\n\t    /**\n\t     * Iterates between child noted and looking for #text node on deepest level\n\t     * @private\n\t     * @param {Element} block - node where find\n\t     * @param {int} postiton - starting postion\n\t     *      Example: childNodex.length to find from the end\n\t     *               or 0 to find from the start\n\t     * @return {Text} block\n\t     * @uses DFS\n\t     */\n\t    content.getDeepestTextNodeFromPosition = function (block, position) {\n\t\n\t        /**\n\t         * Clear Block from empty and useless spaces with trim.\n\t         * Such nodes we should remove\n\t         */\n\t        var blockChilds = block.childNodes,\n\t            index,\n\t            node,\n\t            text;\n\t\n\t        for (index = 0; index < blockChilds.length; index++) {\n\t\n\t            node = blockChilds[index];\n\t\n\t            if (node.nodeType == editor.core.nodeTypes.TEXT) {\n\t\n\t                text = node.textContent.trim();\n\t\n\t                /** Text is empty. We should remove this child from node before we start DFS\n\t                 * decrease the quantity of childs.\n\t                 */\n\t                if (text === '') {\n\t\n\t                    block.removeChild(node);\n\t                    position--;\n\t                }\n\t            }\n\t        }\n\t\n\t        if (block.childNodes.length === 0) {\n\t\n\t            return document.createTextNode('');\n\t        }\n\t\n\t        /** Setting default position when we deleted all empty nodes */\n\t        if (position < 0) position = 1;\n\t\n\t        var lookingFromStart = false;\n\t\n\t        /** For looking from START */\n\t        if (position === 0) {\n\t\n\t            lookingFromStart = true;\n\t            position = 1;\n\t        }\n\t\n\t        while (position) {\n\t\n\t            /** initial verticle of node. */\n\t            if (lookingFromStart) {\n\t\n\t                block = block.childNodes[0];\n\t            } else {\n\t\n\t                block = block.childNodes[position - 1];\n\t            }\n\t\n\t            if (block.nodeType == editor.core.nodeTypes.TAG) {\n\t\n\t                position = block.childNodes.length;\n\t            } else if (block.nodeType == editor.core.nodeTypes.TEXT) {\n\t\n\t                position = 0;\n\t            }\n\t        }\n\t\n\t        return block;\n\t    };\n\t\n\t    /**\n\t     * @private\n\t     */\n\t    content.composeNewBlock = function (block, tool, isStretched) {\n\t\n\t        var newBlock = editor.draw.node('DIV', editor.ui.className.BLOCK_CLASSNAME, {}),\n\t            blockContent = editor.draw.node('DIV', editor.ui.className.BLOCK_CONTENT, {});\n\t\n\t        blockContent.appendChild(block);\n\t        newBlock.appendChild(blockContent);\n\t\n\t        if (isStretched) {\n\t\n\t            blockContent.classList.add(editor.ui.className.BLOCK_STRETCHED);\n\t        }\n\t\n\t        newBlock.dataset.tool = tool;\n\t        return newBlock;\n\t    };\n\t\n\t    /**\n\t     * Returns Range object of current selection\n\t     */\n\t    content.getRange = function () {\n\t\n\t        var selection = window.getSelection().getRangeAt(0);\n\t\n\t        return selection;\n\t    };\n\t\n\t    /**\n\t     * Divides block in two blocks (after and before caret)\n\t     * @private\n\t     * @param {Int} inputIndex - target input index\n\t     */\n\t    content.splitBlock = function (inputIndex) {\n\t\n\t        var selection = window.getSelection(),\n\t            anchorNode = selection.anchorNode,\n\t            anchorNodeText = anchorNode.textContent,\n\t            caretOffset = selection.anchorOffset,\n\t            textBeforeCaret,\n\t            textNodeBeforeCaret,\n\t            textAfterCaret,\n\t            textNodeAfterCaret;\n\t\n\t        var currentBlock = editor.content.currentNode.querySelector('[contentEditable]');\n\t\n\t        textBeforeCaret = anchorNodeText.substring(0, caretOffset);\n\t        textAfterCaret = anchorNodeText.substring(caretOffset);\n\t\n\t        textNodeBeforeCaret = document.createTextNode(textBeforeCaret);\n\t\n\t        if (textAfterCaret) {\n\t\n\t            textNodeAfterCaret = document.createTextNode(textAfterCaret);\n\t        }\n\t\n\t        var previousChilds = [],\n\t            nextChilds = [],\n\t            reachedCurrent = false;\n\t\n\t        if (textNodeAfterCaret) {\n\t\n\t            nextChilds.push(textNodeAfterCaret);\n\t        }\n\t\n\t        for (var i = 0, child; !!(child = currentBlock.childNodes[i]); i++) {\n\t\n\t            if (child != anchorNode) {\n\t\n\t                if (!reachedCurrent) {\n\t\n\t                    previousChilds.push(child);\n\t                } else {\n\t\n\t                    nextChilds.push(child);\n\t                }\n\t            } else {\n\t\n\t                reachedCurrent = true;\n\t            }\n\t        }\n\t\n\t        /** Clear current input */\n\t        editor.state.inputs[inputIndex].innerHTML = '';\n\t\n\t        /**\n\t         * Append all childs founded before anchorNode\n\t         */\n\t        var previousChildsLength = previousChilds.length;\n\t\n\t        for (i = 0; i < previousChildsLength; i++) {\n\t\n\t            editor.state.inputs[inputIndex].appendChild(previousChilds[i]);\n\t        }\n\t\n\t        editor.state.inputs[inputIndex].appendChild(textNodeBeforeCaret);\n\t\n\t        /**\n\t         * Append text node which is after caret\n\t         */\n\t        var nextChildsLength = nextChilds.length,\n\t            newNode = document.createElement('div');\n\t\n\t        for (i = 0; i < nextChildsLength; i++) {\n\t\n\t            newNode.appendChild(nextChilds[i]);\n\t        }\n\t\n\t        newNode = newNode.innerHTML;\n\t\n\t        /** This type of block creates when enter is pressed */\n\t        var NEW_BLOCK_TYPE = editor.settings.initialBlockPlugin;\n\t\n\t        /**\n\t         * Make new paragraph with text after caret\n\t         */\n\t        editor.content.insertBlock({\n\t            type: NEW_BLOCK_TYPE,\n\t            block: editor.tools[NEW_BLOCK_TYPE].render({\n\t                text: newNode\n\t            })\n\t        }, true);\n\t    };\n\t\n\t    /**\n\t     * Merges two blocks  current and target\n\t     * If target index is not exist, then previous will be as target\n\t     */\n\t    content.mergeBlocks = function (currentInputIndex, targetInputIndex) {\n\t\n\t        /** If current input index is zero, then prevent method execution */\n\t        if (currentInputIndex === 0) {\n\t\n\t            return;\n\t        }\n\t\n\t        var targetInput,\n\t            currentInputContent = editor.state.inputs[currentInputIndex].innerHTML;\n\t\n\t        if (!targetInputIndex) {\n\t\n\t            targetInput = editor.state.inputs[currentInputIndex - 1];\n\t        } else {\n\t\n\t            targetInput = editor.state.inputs[targetInputIndex];\n\t        }\n\t\n\t        targetInput.innerHTML += currentInputContent;\n\t    };\n\t\n\t    /**\n\t     * @private\n\t     *\n\t     * Callback for HTML Mutations\n\t     * @param {Array} mutation - Mutation Record\n\t     */\n\t    content.paste = function (mutation) {\n\t\n\t        var workingNode = editor.content.currentNode,\n\t            tool = workingNode.dataset.tool;\n\t\n\t        if (editor.tools[tool].allowedToPaste) {\n\t\n\t            editor.content.sanitize.call(this, mutation.target);\n\t        } else {\n\t\n\t            editor.content.pasteTextContent(mutation.addedNodes);\n\t        }\n\t    };\n\t\n\t    /**\n\t     * @private\n\t     *\n\t     * gets only text/plain content of node\n\t     * @param {Element} target - HTML node\n\t     */\n\t    content.pasteTextContent = function (nodes) {\n\t\n\t        var node = nodes[0],\n\t            textNode;\n\t\n\t        if (!node) {\n\t\n\t            return;\n\t        }\n\t\n\t        if (node.nodeType == editor.core.nodeTypes.TEXT) {\n\t\n\t            textNode = document.createTextNode(node);\n\t        } else {\n\t\n\t            textNode = document.createTextNode(node.textContent);\n\t        }\n\t\n\t        if (editor.core.isDomNode(node)) {\n\t\n\t            node.parentNode.replaceChild(textNode, node);\n\t        }\n\t    };\n\t\n\t    /**\n\t     * @private\n\t     *\n\t     * Sanitizes HTML content\n\t     * @param {Element} target - inserted element\n\t     * @uses Sanitize library html-janitor\n\t     */\n\t    content.sanitize = function (target) {\n\t\n\t        if (!target) {\n\t\n\t            return;\n\t        }\n\t\n\t        var node = target[0];\n\t\n\t        if (!node) {\n\t\n\t            return;\n\t        }\n\t\n\t        /**\n\t         * Disconnect Observer\n\t         * hierarchy of function calls inherits context of observer\n\t         */\n\t        this.disconnect();\n\t\n\t        /**\n\t         * Don't sanitize text node\n\t         */\n\t        if (node.nodeType == editor.core.nodeTypes.TEXT) {\n\t\n\t            return;\n\t        }\n\t\n\t        /**\n\t         * Clear dirty content\n\t         */\n\t        var cleaner = editor.sanitizer.init(editor.satinizer.Config.BASIC),\n\t            clean = cleaner.clean(target.outerHTML);\n\t\n\t        var div = editor.draw.node('DIV', [], { innerHTML: clean });\n\t\n\t        node.replaceWith(div.childNodes[0]);\n\t    };\n\t\n\t    /**\n\t     * Iterates all right siblings and parents, which has right siblings\n\t     * while it does not reached the first-level block\n\t     *\n\t     * @param {Element} node\n\t     * @return {boolean}\n\t     */\n\t    content.isLastNode = function (node) {\n\t\n\t        // console.log('  ');\n\t\n\t        var allChecked = false;\n\t\n\t        while (!allChecked) {\n\t\n\t            // console.log('  %o', node);\n\t            // console.log(',    ');\n\t\n\t            if (!allSiblingsEmpty_(node)) {\n\t\n\t                // console.log('  .   . .');\n\t                return false;\n\t            }\n\t\n\t            node = node.parentNode;\n\t\n\t            /**\n\t             *     ,      \n\t             */\n\t            if (node.classList.contains(editor.ui.className.BLOCK_CONTENT)) {\n\t\n\t                allChecked = true;\n\t            }\n\t        }\n\t\n\t        return true;\n\t    };\n\t\n\t    /**\n\t     * Checks if all element right siblings is empty\n\t     * @param node\n\t     */\n\t    var allSiblingsEmpty_ = function allSiblingsEmpty_(node) {\n\t\n\t        /**\n\t         *  ,      \n\t         */\n\t        var sibling = node.nextSibling;\n\t\n\t        while (sibling) {\n\t\n\t            if (sibling.textContent.length) {\n\t\n\t                return false;\n\t            }\n\t\n\t            sibling = sibling.nextSibling;\n\t        }\n\t\n\t        return true;\n\t    };\n\t\n\t    /**\n\t     * @public\n\t     *\n\t     * @param [String] htmlString - html content as string\n\t     * @return {string} - html content as string\n\t     */\n\t    content.wrapTextWithParagraphs = function (htmlString) {\n\t\n\t        var wrapper = document.createElement('DIV'),\n\t            newWrapper = document.createElement('DIV'),\n\t            i,\n\t            paragraph,\n\t            firstLevelBlocks = ['DIV', 'P'],\n\t            blockTyped,\n\t            node;\n\t\n\t        /**\n\t         * Make HTML Element to Wrap Text\n\t         * It allows us to work with input data as HTML content\n\t         */\n\t        wrapper.innerHTML = htmlString;\n\t        paragraph = document.createElement('P');\n\t\n\t        for (i = 0; i < wrapper.childNodes.length; i++) {\n\t\n\t            node = wrapper.childNodes[i];\n\t\n\t            blockTyped = firstLevelBlocks.indexOf(node.tagName) != -1;\n\t\n\t            /**\n\t             * If node is first-levet\n\t             * we add this node to our new wrapper\n\t             */\n\t            if (blockTyped) {\n\t\n\t                /**\n\t                 * If we had splitted inline nodes to paragraph before\n\t                 */\n\t                if (paragraph.childNodes.length) {\n\t\n\t                    newWrapper.appendChild(paragraph.cloneNode(true));\n\t\n\t                    /** empty paragraph */\n\t                    paragraph = null;\n\t                    paragraph = document.createElement('P');\n\t                }\n\t\n\t                newWrapper.appendChild(node.cloneNode(true));\n\t            } else {\n\t\n\t                /** Collect all inline nodes to one as paragraph */\n\t                paragraph.appendChild(node.cloneNode(true));\n\t\n\t                /** if node is last we should append this node to paragraph and paragraph to new wrapper */\n\t                if (i == wrapper.childNodes.length - 1) {\n\t\n\t                    newWrapper.appendChild(paragraph.cloneNode(true));\n\t                }\n\t            }\n\t        }\n\t\n\t        return newWrapper.innerHTML;\n\t    };\n\t\n\t    return content;\n\t}({});\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t/**\n\t * Codex Editor toolbar module\n\t *\n\t * Contains:\n\t *  - Inline toolbox\n\t *  - Toolbox within plus button\n\t *  - Settings section\n\t *\n\t * @author Codex Team\n\t * @version 1.0\n\t */\n\t\n\tvar editor = codex.editor;\n\t\n\tmodule.exports = function (toolbar) {\n\t\n\t    toolbar.settings = __webpack_require__(8);\n\t    toolbar.inline = __webpack_require__(9);\n\t    toolbar.toolbox = __webpack_require__(10);\n\t\n\t    /**\n\t     * Margin between focused node and toolbar\n\t     */\n\t    toolbar.defaultToolbarHeight = 49;\n\t\n\t    toolbar.defaultOffset = 34;\n\t\n\t    toolbar.opened = false;\n\t\n\t    toolbar.current = null;\n\t\n\t    /**\n\t     * @protected\n\t     */\n\t    toolbar.open = function () {\n\t\n\t        editor.nodes.toolbar.classList.add('opened');\n\t        this.opened = true;\n\t    };\n\t\n\t    /**\n\t     * @protected\n\t     */\n\t    toolbar.close = function () {\n\t\n\t        editor.nodes.toolbar.classList.remove('opened');\n\t\n\t        toolbar.opened = false;\n\t        toolbar.current = null;\n\t\n\t        for (var button in editor.nodes.toolbarButtons) {\n\t\n\t            editor.nodes.toolbarButtons[button].classList.remove('selected');\n\t        }\n\t\n\t        /** Close toolbox when toolbar is not displayed */\n\t        editor.toolbar.toolbox.close();\n\t        editor.toolbar.settings.close();\n\t    };\n\t\n\t    toolbar.toggle = function () {\n\t\n\t        if (!this.opened) {\n\t\n\t            this.open();\n\t        } else {\n\t\n\t            this.close();\n\t        }\n\t    };\n\t\n\t    toolbar.hidePlusButton = function () {\n\t\n\t        editor.nodes.plusButton.classList.add('hide');\n\t    };\n\t\n\t    toolbar.showPlusButton = function () {\n\t\n\t        editor.nodes.plusButton.classList.remove('hide');\n\t    };\n\t\n\t    /**\n\t     * Moving toolbar to the specified node\n\t     */\n\t    toolbar.move = function () {\n\t\n\t        /** Close Toolbox when we move toolbar */\n\t        editor.toolbar.toolbox.close();\n\t\n\t        if (!editor.content.currentNode) {\n\t\n\t            return;\n\t        }\n\t\n\t        var newYCoordinate = editor.content.currentNode.offsetTop - editor.toolbar.defaultToolbarHeight / 2 + editor.toolbar.defaultOffset;\n\t\n\t        editor.nodes.toolbar.style.transform = 'translate3D(0, ' + Math.floor(newYCoordinate) + 'px, 0)';\n\t\n\t        /** Close trash actions */\n\t        editor.toolbar.settings.hideRemoveActions();\n\t    };\n\t\n\t    return toolbar;\n\t}({});\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t/**\n\t * Toolbar settings\n\t *\n\t * @version 1.0.4\n\t */\n\t\n\tvar editor = codex.editor;\n\t\n\tmodule.exports = function (settings) {\n\t\n\t    settings.opened = false;\n\t\n\t    settings.setting = null;\n\t    settings.actions = null;\n\t\n\t    settings.cover = null;\n\t\n\t    /**\n\t     * Append and open settings\n\t     */\n\t    settings.open = function (toolType) {\n\t\n\t        /**\n\t         * Append settings content\n\t         * It's stored in tool.settings\n\t         */\n\t        if (!editor.tools[toolType] || !editor.tools[toolType].makeSettings) {\n\t\n\t            editor.core.log('Plugin \\xAB' + toolType + '\\xBB has no settings', 'warn');\n\t            // editor.nodes.pluginSettings.innerHTML = ` ${toolType}   `;\n\t        } else {\n\t\n\t            /**\n\t             * Draw settings block\n\t             */\n\t            var settingsBlock = editor.tools[toolType].makeSettings();\n\t\n\t            editor.nodes.pluginSettings.appendChild(settingsBlock);\n\t        }\n\t\n\t        /** Open settings block */\n\t        editor.nodes.blockSettings.classList.add('opened');\n\t        editor.toolbar.settings.addDefaultSettings();\n\t        this.opened = true;\n\t    };\n\t\n\t    /**\n\t     * Close and clear settings\n\t     */\n\t    settings.close = function () {\n\t\n\t        editor.nodes.blockSettings.classList.remove('opened');\n\t        editor.nodes.pluginSettings.innerHTML = '';\n\t\n\t        this.opened = false;\n\t    };\n\t\n\t    /**\n\t     * @param {string} toolType - plugin type\n\t     */\n\t    settings.toggle = function (toolType) {\n\t\n\t        if (!this.opened) {\n\t\n\t            this.open(toolType);\n\t        } else {\n\t\n\t            this.close();\n\t        }\n\t    };\n\t\n\t    /**\n\t     * This function adds default core settings\n\t     */\n\t    settings.addDefaultSettings = function () {\n\t\n\t        /** list of default settings */\n\t        var feedModeToggler;\n\t\n\t        /** Clear block and append initialized settings */\n\t        editor.nodes.defaultSettings.innerHTML = '';\n\t\n\t        /** Init all default setting buttons */\n\t        feedModeToggler = editor.toolbar.settings.makeFeedModeToggler();\n\t\n\t        /**\n\t         * Fill defaultSettings\n\t         */\n\t\n\t        /**\n\t         * Button that enables/disables Feed-mode\n\t         * Feed-mode means that block will be showed in articles-feed like cover\n\t         */\n\t        editor.nodes.defaultSettings.appendChild(feedModeToggler);\n\t    };\n\t\n\t    /**\n\t     * Cover setting.\n\t     * This tune highlights block, so that it may be used for showing target block on main page\n\t     * Draw different setting when block is marked for main page\n\t     * If TRUE, then we show button that removes this selection\n\t     * Also defined setting \"Click\" events will be listened and have separate callbacks\n\t     *\n\t     * @return {Element} node/button that we place in default settings block\n\t     */\n\t    settings.makeFeedModeToggler = function () {\n\t\n\t        var isFeedModeActivated = editor.toolbar.settings.isFeedModeActivated(),\n\t            setting,\n\t            data;\n\t\n\t        if (!isFeedModeActivated) {\n\t\n\t            data = {\n\t                innerHTML: '<i class=\"ce-icon-newspaper\"></i>  '\n\t            };\n\t        } else {\n\t\n\t            data = {\n\t                innerHTML: '<i class=\"ce-icon-newspaper\"></i>   '\n\t            };\n\t        }\n\t\n\t        setting = editor.draw.node('DIV', editor.ui.className.SETTINGS_ITEM, data);\n\t        setting.addEventListener('click', editor.toolbar.settings.updateFeedMode, false);\n\t\n\t        return setting;\n\t    };\n\t\n\t    /**\n\t     * Updates Feed-mode\n\t     */\n\t    settings.updateFeedMode = function () {\n\t\n\t        var currentNode = editor.content.currentNode;\n\t\n\t        currentNode.classList.toggle(editor.ui.className.BLOCK_IN_FEED_MODE);\n\t\n\t        editor.toolbar.settings.close();\n\t    };\n\t\n\t    settings.isFeedModeActivated = function () {\n\t\n\t        var currentBlock = editor.content.currentNode;\n\t\n\t        if (currentBlock) {\n\t\n\t            return currentBlock.classList.contains(editor.ui.className.BLOCK_IN_FEED_MODE);\n\t        } else {\n\t\n\t            return false;\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Here we will draw buttons and add listeners to components\n\t     */\n\t    settings.makeRemoveBlockButton = function () {\n\t\n\t        var removeBlockWrapper = editor.draw.node('SPAN', 'ce-toolbar__remove-btn', {}),\n\t            settingButton = editor.draw.node('SPAN', 'ce-toolbar__remove-setting', { innerHTML: '<i class=\"ce-icon-trash\"></i>' }),\n\t            actionWrapper = editor.draw.node('DIV', 'ce-toolbar__remove-confirmation', {}),\n\t            confirmAction = editor.draw.node('DIV', 'ce-toolbar__remove-confirm', { textContent: ' ' }),\n\t            cancelAction = editor.draw.node('DIV', 'ce-toolbar__remove-cancel', { textContent: '' });\n\t\n\t        settingButton.addEventListener('click', editor.toolbar.settings.removeButtonClicked, false);\n\t\n\t        confirmAction.addEventListener('click', editor.toolbar.settings.confirmRemovingRequest, false);\n\t\n\t        cancelAction.addEventListener('click', editor.toolbar.settings.cancelRemovingRequest, false);\n\t\n\t        actionWrapper.appendChild(confirmAction);\n\t        actionWrapper.appendChild(cancelAction);\n\t\n\t        removeBlockWrapper.appendChild(settingButton);\n\t        removeBlockWrapper.appendChild(actionWrapper);\n\t\n\t        /** Save setting */\n\t        editor.toolbar.settings.setting = settingButton;\n\t        editor.toolbar.settings.actions = actionWrapper;\n\t\n\t        return removeBlockWrapper;\n\t    };\n\t\n\t    settings.removeButtonClicked = function () {\n\t\n\t        var action = editor.toolbar.settings.actions;\n\t\n\t        if (action.classList.contains('opened')) {\n\t\n\t            editor.toolbar.settings.hideRemoveActions();\n\t        } else {\n\t\n\t            editor.toolbar.settings.showRemoveActions();\n\t        }\n\t\n\t        editor.toolbar.toolbox.close();\n\t        editor.toolbar.settings.close();\n\t    };\n\t\n\t    settings.cancelRemovingRequest = function () {\n\t\n\t        editor.toolbar.settings.actions.classList.remove('opened');\n\t    };\n\t\n\t    settings.confirmRemovingRequest = function () {\n\t\n\t        var currentBlock = editor.content.currentNode,\n\t            firstLevelBlocksCount;\n\t\n\t        currentBlock.remove();\n\t\n\t        firstLevelBlocksCount = editor.nodes.redactor.childNodes.length;\n\t\n\t        /**\n\t         * If all blocks are removed\n\t         */\n\t        if (firstLevelBlocksCount === 0) {\n\t\n\t            /** update currentNode variable */\n\t            editor.content.currentNode = null;\n\t\n\t            /** Inserting new empty initial block */\n\t            editor.ui.addInitialBlock();\n\t        }\n\t\n\t        editor.ui.saveInputs();\n\t\n\t        editor.toolbar.close();\n\t    };\n\t\n\t    settings.showRemoveActions = function () {\n\t\n\t        editor.toolbar.settings.actions.classList.add('opened');\n\t    };\n\t\n\t    settings.hideRemoveActions = function () {\n\t\n\t        editor.toolbar.settings.actions.classList.remove('opened');\n\t    };\n\t\n\t    return settings;\n\t}({});\n\n/***/ },\n/* 9 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t/**\n\t * Inline toolbar\n\t *\n\t * Contains from tools:\n\t * Bold, Italic, Underline and Anchor\n\t *\n\t * @author Codex Team\n\t * @version 1.0\n\t */\n\t\n\tvar editor = codex.editor;\n\t\n\tmodule.exports = function (inline) {\n\t\n\t    inline.buttonsOpened = null;\n\t    inline.actionsOpened = null;\n\t    inline.wrappersOffset = null;\n\t\n\t    /**\n\t     * saving selection that need for execCommand for styling\n\t     *\n\t     */\n\t    inline.storedSelection = null;\n\t\n\t    /**\n\t     * @protected\n\t     *\n\t     * Open inline toobar\n\t     */\n\t    inline.show = function () {\n\t\n\t        var currentNode = editor.content.currentNode,\n\t            tool = currentNode.dataset.tool,\n\t            plugin;\n\t\n\t        /**\n\t         * tool allowed to open inline toolbar\n\t         */\n\t        plugin = editor.tools[tool];\n\t\n\t        if (!plugin.showInlineToolbar) return;\n\t\n\t        var selectedText = inline.getSelectionText(),\n\t            toolbar = editor.nodes.inlineToolbar.wrapper;\n\t\n\t        if (selectedText.length > 0) {\n\t\n\t            /** Move toolbar and open */\n\t            editor.toolbar.inline.move();\n\t\n\t            /** Open inline toolbar */\n\t            toolbar.classList.add('opened');\n\t\n\t            /** show buttons of inline toolbar */\n\t            editor.toolbar.inline.showButtons();\n\t        }\n\t    };\n\t\n\t    /**\n\t     * @protected\n\t     *\n\t     * Closes inline toolbar\n\t     */\n\t    inline.close = function () {\n\t\n\t        var toolbar = editor.nodes.inlineToolbar.wrapper;\n\t\n\t        toolbar.classList.remove('opened');\n\t    };\n\t\n\t    /**\n\t     * @private\n\t     *\n\t     * Moving toolbar\n\t     */\n\t    inline.move = function () {\n\t\n\t        if (!this.wrappersOffset) {\n\t\n\t            this.wrappersOffset = this.getWrappersOffset();\n\t        }\n\t\n\t        var coords = this.getSelectionCoords(),\n\t            defaultOffset = 0,\n\t            toolbar = editor.nodes.inlineToolbar.wrapper,\n\t            newCoordinateX,\n\t            newCoordinateY;\n\t\n\t        if (toolbar.offsetHeight === 0) {\n\t\n\t            defaultOffset = 40;\n\t        }\n\t\n\t        newCoordinateX = coords.x - this.wrappersOffset.left;\n\t        newCoordinateY = coords.y + window.scrollY - this.wrappersOffset.top - defaultOffset - toolbar.offsetHeight;\n\t\n\t        toolbar.style.transform = 'translate3D(' + Math.floor(newCoordinateX) + 'px, ' + Math.floor(newCoordinateY) + 'px, 0)';\n\t\n\t        /** Close everything */\n\t        editor.toolbar.inline.closeButtons();\n\t        editor.toolbar.inline.closeAction();\n\t    };\n\t\n\t    /**\n\t     * @private\n\t     *\n\t     * Tool Clicked\n\t     */\n\t\n\t    inline.toolClicked = function (event, type) {\n\t\n\t        /**\n\t         * For simple tools we use default browser function\n\t         * For more complicated tools, we should write our own behavior\n\t         */\n\t        switch (type) {\n\t            case 'createLink':\n\t                editor.toolbar.inline.createLinkAction(event, type);break;\n\t            default:\n\t                editor.toolbar.inline.defaultToolAction(type);break;\n\t        }\n\t\n\t        /**\n\t         * highlight buttons\n\t         * after making some action\n\t         */\n\t        editor.nodes.inlineToolbar.buttons.childNodes.forEach(editor.toolbar.inline.hightlight);\n\t    };\n\t\n\t    /**\n\t     * @private\n\t     *\n\t     * Saving wrappers offset in DOM\n\t     */\n\t    inline.getWrappersOffset = function () {\n\t\n\t        var wrapper = editor.nodes.wrapper,\n\t            offset = this.getOffset(wrapper);\n\t\n\t        this.wrappersOffset = offset;\n\t        return offset;\n\t    };\n\t\n\t    /**\n\t     * @private\n\t     *\n\t     * Calculates offset of DOM element\n\t     *\n\t     * @param el\n\t     * @returns {{top: number, left: number}}\n\t     */\n\t    inline.getOffset = function (el) {\n\t\n\t        var _x = 0;\n\t        var _y = 0;\n\t\n\t        while (el && !isNaN(el.offsetLeft) && !isNaN(el.offsetTop)) {\n\t\n\t            _x += el.offsetLeft + el.clientLeft;\n\t            _y += el.offsetTop + el.clientTop;\n\t            el = el.offsetParent;\n\t        }\n\t        return { top: _y, left: _x };\n\t    };\n\t\n\t    /**\n\t     * @private\n\t     *\n\t     * Calculates position of selected text\n\t     * @returns {{x: number, y: number}}\n\t     */\n\t    inline.getSelectionCoords = function () {\n\t\n\t        var sel = document.selection,\n\t            range;\n\t        var x = 0,\n\t            y = 0;\n\t\n\t        if (sel) {\n\t\n\t            if (sel.type != 'Control') {\n\t\n\t                range = sel.createRange();\n\t                range.collapse(true);\n\t                x = range.boundingLeft;\n\t                y = range.boundingTop;\n\t            }\n\t        } else if (window.getSelection) {\n\t\n\t            sel = window.getSelection();\n\t\n\t            if (sel.rangeCount) {\n\t\n\t                range = sel.getRangeAt(0).cloneRange();\n\t                if (range.getClientRects) {\n\t\n\t                    range.collapse(true);\n\t                    var rect = range.getClientRects()[0];\n\t\n\t                    if (!rect) {\n\t\n\t                        return;\n\t                    }\n\t\n\t                    x = rect.left;\n\t                    y = rect.top;\n\t                }\n\t            }\n\t        }\n\t        return { x: x, y: y };\n\t    };\n\t\n\t    /**\n\t     * @private\n\t     *\n\t     * Returns selected text as String\n\t     * @returns {string}\n\t     */\n\t    inline.getSelectionText = function () {\n\t\n\t        var selectedText = '';\n\t\n\t        // all modern browsers and IE9+\n\t        if (window.getSelection) {\n\t\n\t            selectedText = window.getSelection().toString();\n\t        }\n\t\n\t        return selectedText;\n\t    };\n\t\n\t    /** Opens buttons block */\n\t    inline.showButtons = function () {\n\t\n\t        var buttons = editor.nodes.inlineToolbar.buttons;\n\t\n\t        buttons.classList.add('opened');\n\t\n\t        editor.toolbar.inline.buttonsOpened = true;\n\t\n\t        /** highlight buttons */\n\t        editor.nodes.inlineToolbar.buttons.childNodes.forEach(editor.toolbar.inline.hightlight);\n\t    };\n\t\n\t    /** Makes buttons disappear */\n\t    inline.closeButtons = function () {\n\t\n\t        var buttons = editor.nodes.inlineToolbar.buttons;\n\t\n\t        buttons.classList.remove('opened');\n\t\n\t        editor.toolbar.inline.buttonsOpened = false;\n\t    };\n\t\n\t    /** Open buttons defined action if exist */\n\t    inline.showActions = function () {\n\t\n\t        var action = editor.nodes.inlineToolbar.actions;\n\t\n\t        action.classList.add('opened');\n\t\n\t        editor.toolbar.inline.actionsOpened = true;\n\t    };\n\t\n\t    /** Close actions block */\n\t    inline.closeAction = function () {\n\t\n\t        var action = editor.nodes.inlineToolbar.actions;\n\t\n\t        action.innerHTML = '';\n\t        action.classList.remove('opened');\n\t        editor.toolbar.inline.actionsOpened = false;\n\t    };\n\t\n\t    /**\n\t    * Callback for keydowns in inline toolbar \"Insert link...\" input\n\t    */\n\t    var inlineToolbarAnchorInputKeydown_ = function inlineToolbarAnchorInputKeydown_(event) {\n\t\n\t        if (event.keyCode != editor.core.keys.ENTER) {\n\t\n\t            return;\n\t        }\n\t\n\t        var editable = editor.content.currentNode,\n\t            storedSelection = editor.toolbar.inline.storedSelection;\n\t\n\t        editor.toolbar.inline.restoreSelection(editable, storedSelection);\n\t        editor.toolbar.inline.setAnchor(this.value);\n\t\n\t        /**\n\t         * Preventing events that will be able to happen\n\t         */\n\t        event.preventDefault();\n\t        event.stopImmediatePropagation();\n\t\n\t        editor.toolbar.inline.clearRange();\n\t    };\n\t\n\t    /** Action for link creation or for setting anchor */\n\t    inline.createLinkAction = function (event) {\n\t\n\t        var isActive = this.isLinkActive();\n\t\n\t        var editable = editor.content.currentNode,\n\t            storedSelection = editor.toolbar.inline.saveSelection(editable);\n\t\n\t        /** Save globally selection */\n\t        editor.toolbar.inline.storedSelection = storedSelection;\n\t\n\t        if (isActive) {\n\t\n\t            /**\n\t             * Changing stored selection. if we want to remove anchor from word\n\t             * we should remove anchor from whole word, not only selected part.\n\t             * The solution is than we get the length of current link\n\t             * Change start position to - end of selection minus length of anchor\n\t             */\n\t            editor.toolbar.inline.restoreSelection(editable, storedSelection);\n\t\n\t            editor.toolbar.inline.defaultToolAction('unlink');\n\t        } else {\n\t\n\t            /** Create input and close buttons */\n\t            var action = editor.draw.inputForLink();\n\t\n\t            editor.nodes.inlineToolbar.actions.appendChild(action);\n\t\n\t            editor.toolbar.inline.closeButtons();\n\t            editor.toolbar.inline.showActions();\n\t\n\t            /**\n\t             * focus to input\n\t             * Solution: https://developer.mozilla.org/ru/docs/Web/API/HTMLElement/focus\n\t             * Prevents event after showing input and when we need to focus an input which is in unexisted form\n\t             */\n\t            action.focus();\n\t            event.preventDefault();\n\t\n\t            /** Callback to link action */\n\t            action.addEventListener('keydown', inlineToolbarAnchorInputKeydown_, false);\n\t        }\n\t    };\n\t\n\t    inline.isLinkActive = function () {\n\t\n\t        var isActive = false;\n\t\n\t        editor.nodes.inlineToolbar.buttons.childNodes.forEach(function (tool) {\n\t\n\t            var dataType = tool.dataset.type;\n\t\n\t            if (dataType == 'link' && tool.classList.contains('hightlighted')) {\n\t\n\t                isActive = true;\n\t            }\n\t        });\n\t\n\t        return isActive;\n\t    };\n\t\n\t    /** default action behavior of tool */\n\t    inline.defaultToolAction = function (type) {\n\t\n\t        document.execCommand(type, false, null);\n\t    };\n\t\n\t    /**\n\t     * @private\n\t     *\n\t     * Sets URL\n\t     *\n\t     * @param {String} url - URL\n\t     */\n\t    inline.setAnchor = function (url) {\n\t\n\t        document.execCommand('createLink', false, url);\n\t\n\t        /** Close after URL inserting */\n\t        editor.toolbar.inline.closeAction();\n\t    };\n\t\n\t    /**\n\t     * @private\n\t     *\n\t     * Saves selection\n\t     */\n\t    inline.saveSelection = function (containerEl) {\n\t\n\t        var range = window.getSelection().getRangeAt(0),\n\t            preSelectionRange = range.cloneRange(),\n\t            start;\n\t\n\t        preSelectionRange.selectNodeContents(containerEl);\n\t        preSelectionRange.setEnd(range.startContainer, range.startOffset);\n\t\n\t        start = preSelectionRange.toString().length;\n\t\n\t        return {\n\t            start: start,\n\t            end: start + range.toString().length\n\t        };\n\t    };\n\t\n\t    /**\n\t     * @private\n\t     *\n\t     * Sets to previous selection (Range)\n\t     *\n\t     * @param {Element} containerEl - editable element where we restore range\n\t     * @param {Object} savedSel - range basic information to restore\n\t     */\n\t    inline.restoreSelection = function (containerEl, savedSel) {\n\t\n\t        var range = document.createRange(),\n\t            charIndex = 0;\n\t\n\t        range.setStart(containerEl, 0);\n\t        range.collapse(true);\n\t\n\t        var nodeStack = [containerEl],\n\t            node,\n\t            foundStart = false,\n\t            stop = false,\n\t            nextCharIndex;\n\t\n\t        while (!stop && (node = nodeStack.pop())) {\n\t\n\t            if (node.nodeType == 3) {\n\t\n\t                nextCharIndex = charIndex + node.length;\n\t\n\t                if (!foundStart && savedSel.start >= charIndex && savedSel.start <= nextCharIndex) {\n\t\n\t                    range.setStart(node, savedSel.start - charIndex);\n\t                    foundStart = true;\n\t                }\n\t                if (foundStart && savedSel.end >= charIndex && savedSel.end <= nextCharIndex) {\n\t\n\t                    range.setEnd(node, savedSel.end - charIndex);\n\t                    stop = true;\n\t                }\n\t                charIndex = nextCharIndex;\n\t            } else {\n\t\n\t                var i = node.childNodes.length;\n\t\n\t                while (i--) {\n\t\n\t                    nodeStack.push(node.childNodes[i]);\n\t                }\n\t            }\n\t        }\n\t\n\t        var sel = window.getSelection();\n\t\n\t        sel.removeAllRanges();\n\t        sel.addRange(range);\n\t    };\n\t\n\t    /**\n\t     * @private\n\t     *\n\t     * Removes all ranges from window selection\n\t     */\n\t    inline.clearRange = function () {\n\t\n\t        var selection = window.getSelection();\n\t\n\t        selection.removeAllRanges();\n\t    };\n\t\n\t    /**\n\t     * @private\n\t     *\n\t     * sets or removes hightlight\n\t     */\n\t    inline.hightlight = function (tool) {\n\t\n\t        var dataType = tool.dataset.type;\n\t\n\t        if (document.queryCommandState(dataType)) {\n\t\n\t            editor.toolbar.inline.setButtonHighlighted(tool);\n\t        } else {\n\t\n\t            editor.toolbar.inline.removeButtonsHighLight(tool);\n\t        }\n\t\n\t        /**\n\t         *\n\t         * hightlight for anchors\n\t         */\n\t        var selection = window.getSelection(),\n\t            tag = selection.anchorNode.parentNode;\n\t\n\t        if (tag.tagName == 'A' && dataType == 'link') {\n\t\n\t            editor.toolbar.inline.setButtonHighlighted(tool);\n\t        }\n\t    };\n\t\n\t    /**\n\t     * @private\n\t     *\n\t     * Mark button if text is already executed\n\t     */\n\t    inline.setButtonHighlighted = function (button) {\n\t\n\t        button.classList.add('hightlighted');\n\t\n\t        /** At link tool we also change icon */\n\t        if (button.dataset.type == 'link') {\n\t\n\t            var icon = button.childNodes[0];\n\t\n\t            icon.classList.remove('ce-icon-link');\n\t            icon.classList.add('ce-icon-unlink');\n\t        }\n\t    };\n\t\n\t    /**\n\t     * @private\n\t     *\n\t     * Removes hightlight\n\t     */\n\t    inline.removeButtonsHighLight = function (button) {\n\t\n\t        button.classList.remove('hightlighted');\n\t\n\t        /** At link tool we also change icon */\n\t        if (button.dataset.type == 'link') {\n\t\n\t            var icon = button.childNodes[0];\n\t\n\t            icon.classList.remove('ce-icon-unlink');\n\t            icon.classList.add('ce-icon-link');\n\t        }\n\t    };\n\t\n\t    return inline;\n\t}({});\n\n/***/ },\n/* 10 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t/**\n\t * Codex Editor toolbox\n\t *\n\t * All tools be able to appended here\n\t *\n\t * @author Codex Team\n\t * @version 1.0\n\t */\n\t\n\tvar editor = codex.editor;\n\t\n\tmodule.exports = function (toolbox) {\n\t\n\t    toolbox.opened = false;\n\t\n\t    /** Shows toolbox */\n\t    toolbox.open = function () {\n\t\n\t        /** Close setting if toolbox is opened */\n\t        if (editor.toolbar.settings.opened) {\n\t\n\t            editor.toolbar.settings.close();\n\t        }\n\t\n\t        /** display toolbox */\n\t        editor.nodes.toolbox.classList.add('opened');\n\t\n\t        /** Animate plus button */\n\t        editor.nodes.plusButton.classList.add('clicked');\n\t\n\t        /** toolbox state */\n\t        editor.toolbar.toolbox.opened = true;\n\t    };\n\t\n\t    /** Closes toolbox */\n\t    toolbox.close = function () {\n\t\n\t        /** Makes toolbox disapear */\n\t        editor.nodes.toolbox.classList.remove('opened');\n\t\n\t        /** Rotate plus button */\n\t        editor.nodes.plusButton.classList.remove('clicked');\n\t\n\t        /** toolbox state */\n\t        editor.toolbar.toolbox.opened = false;\n\t    };\n\t\n\t    toolbox.leaf = function () {\n\t\n\t        var currentTool = editor.toolbar.current,\n\t            tools = Object.keys(editor.tools),\n\t            barButtons = editor.nodes.toolbarButtons,\n\t            nextToolIndex = 0,\n\t            toolToSelect = void 0,\n\t            visibleTool = void 0,\n\t            tool = void 0;\n\t\n\t        if (!currentTool) {\n\t\n\t            /** Get first tool from object*/\n\t            for (tool in editor.tools) {\n\t\n\t                if (editor.tools[tool].displayInToolbox) {\n\t\n\t                    break;\n\t                }\n\t\n\t                nextToolIndex++;\n\t            }\n\t        } else {\n\t\n\t            nextToolIndex = tools.indexOf(currentTool) + 1;\n\t            visibleTool = tools[nextToolIndex];\n\t\n\t            while (!editor.tools[visibleTool].displayInToolbox) {\n\t\n\t                nextToolIndex++;\n\t                visibleTool = tools[nextToolIndex];\n\t\n\t                if (nextToolIndex == tools.length) {\n\t\n\t                    nextToolIndex = 0;\n\t                    visibleTool = tools[nextToolIndex];\n\t                }\n\t            }\n\t        }\n\t\n\t        toolToSelect = tools[nextToolIndex];\n\t\n\t        for (var button in barButtons) {\n\t\n\t            barButtons[button].classList.remove('selected');\n\t        }\n\t\n\t        barButtons[toolToSelect].classList.add('selected');\n\t        editor.toolbar.current = toolToSelect;\n\t    };\n\t\n\t    /**\n\t     * Transforming selected node type into selected toolbar element type\n\t     * @param {event} event\n\t     */\n\t    toolbox.toolClicked = function (event) {\n\t\n\t        /**\n\t         * UNREPLACEBLE_TOOLS this types of tools are forbidden to replace even they are empty\n\t         */\n\t        var UNREPLACEBLE_TOOLS = ['image', 'link', 'list', 'instagram', 'twitter', 'embed'],\n\t            tool = editor.tools[editor.toolbar.current],\n\t            workingNode = editor.content.currentNode,\n\t            currentInputIndex = editor.caret.inputIndex,\n\t            newBlockContent,\n\t            appendCallback,\n\t            blockData;\n\t\n\t        /** Make block from plugin */\n\t        newBlockContent = tool.render();\n\t\n\t        /** information about block */\n\t        blockData = {\n\t            block: newBlockContent,\n\t            type: tool.type,\n\t            stretched: false\n\t        };\n\t\n\t        if (workingNode && UNREPLACEBLE_TOOLS.indexOf(workingNode.dataset.tool) === -1 && workingNode.textContent.trim() === '') {\n\t\n\t            /** Replace current block */\n\t            editor.content.switchBlock(workingNode, newBlockContent, tool.type);\n\t        } else {\n\t\n\t            /** Insert new Block from plugin */\n\t            editor.content.insertBlock(blockData);\n\t\n\t            /** increase input index */\n\t            currentInputIndex++;\n\t        }\n\t\n\t        /** Fire tool append callback  */\n\t        appendCallback = tool.appendCallback;\n\t\n\t        if (appendCallback && typeof appendCallback == 'function') {\n\t\n\t            appendCallback.call(event);\n\t        }\n\t\n\t        window.setTimeout(function () {\n\t\n\t            /** Set caret to current block */\n\t            editor.caret.setToBlock(currentInputIndex);\n\t        }, 10);\n\t\n\t        /**\n\t         * Changing current Node\n\t         */\n\t        editor.content.workingNodeChanged();\n\t\n\t        /**\n\t         * Move toolbar when node is changed\n\t         */\n\t        editor.toolbar.move();\n\t    };\n\t\n\t    return toolbox;\n\t}({});\n\n/***/ },\n/* 11 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t/**\n\t * Codex Editor callbacks module\n\t *\n\t * @author Codex Team\n\t * @version 1.3.7\n\t */\n\tvar editor = codex.editor;\n\t\n\tmodule.exports = function (callbacks) {\n\t\n\t    callbacks.globalKeydown = function (event) {\n\t\n\t        switch (event.keyCode) {\n\t            case editor.core.keys.ENTER:\n\t                editor.callback.enterKeyPressed(event);break;\n\t        }\n\t    };\n\t\n\t    callbacks.redactorKeyDown = function (event) {\n\t\n\t        switch (event.keyCode) {\n\t            case editor.core.keys.TAB:\n\t                editor.callback.tabKeyPressed(event);break;\n\t            case editor.core.keys.ENTER:\n\t                editor.callback.enterKeyPressedOnRedactorZone(event);break;\n\t            case editor.core.keys.ESC:\n\t                editor.callback.escapeKeyPressed(event);break;\n\t            default:\n\t                editor.callback.defaultKeyPressed(event);break;\n\t        }\n\t    };\n\t\n\t    callbacks.globalKeyup = function (event) {\n\t\n\t        switch (event.keyCode) {\n\t            case editor.core.keys.UP:\n\t            case editor.core.keys.LEFT:\n\t            case editor.core.keys.RIGHT:\n\t            case editor.core.keys.DOWN:\n\t                editor.callback.arrowKeyPressed(event);break;\n\t        }\n\t    };\n\t\n\t    callbacks.tabKeyPressed = function (event) {\n\t\n\t        if (!editor.toolbar.opened) {\n\t\n\t            editor.toolbar.open();\n\t        }\n\t\n\t        if (editor.toolbar.opened && !editor.toolbar.toolbox.opened) {\n\t\n\t            editor.toolbar.toolbox.open();\n\t        } else {\n\t\n\t            editor.toolbar.toolbox.leaf();\n\t        }\n\t\n\t        event.preventDefault();\n\t    };\n\t\n\t    /**\n\t    * @param {Event} event\n\t    */\n\t    callbacks.enterKeyPressed = function () {\n\t\n\t        if (editor.content.editorAreaHightlighted) {\n\t\n\t            /**\n\t             * it means that we lose input index, saved index before is not correct\n\t             * therefore we need to set caret when we insert new block\n\t             */\n\t            editor.caret.inputIndex = -1;\n\t\n\t            editor.callback.enterPressedOnBlock();\n\t        }\n\t    };\n\t\n\t    /**\n\t     * ENTER key handler\n\t     * Makes new paragraph block\n\t     */\n\t    callbacks.enterKeyPressedOnRedactorZone = function (event) {\n\t\n\t        if (event.target.contentEditable == 'true') {\n\t\n\t            /** Update input index */\n\t            editor.caret.saveCurrentInputIndex();\n\t        }\n\t\n\t        var currentInputIndex = editor.caret.getCurrentInputIndex() || 0,\n\t            workingNode = editor.content.currentNode,\n\t            tool = workingNode.dataset.tool,\n\t            isEnterPressedOnToolbar = editor.toolbar.opened && editor.toolbar.current && event.target == editor.state.inputs[currentInputIndex];\n\t\n\t        /** The list of tools which needs the default browser behaviour */\n\t        var enableLineBreaks = editor.tools[tool].enableLineBreaks;\n\t\n\t        /** This type of block creates when enter is pressed */\n\t        var NEW_BLOCK_TYPE = editor.settings.initialBlockPlugin;\n\t\n\t        /**\n\t         * When toolbar is opened, select tool instead of making new paragraph\n\t         */\n\t        if (isEnterPressedOnToolbar) {\n\t\n\t            event.preventDefault();\n\t\n\t            editor.toolbar.toolbox.toolClicked(event);\n\t\n\t            editor.toolbar.close();\n\t\n\t            /**\n\t             * Stop other listeners callback executions\n\t             */\n\t            event.stopPropagation();\n\t            event.stopImmediatePropagation();\n\t\n\t            return;\n\t        }\n\t\n\t        /**\n\t         * Allow paragraph lineBreaks with shift enter\n\t         * Or if shiftkey pressed and enter and enabledLineBreaks, the let new block creation\n\t         */\n\t        if (event.shiftKey || enableLineBreaks) {\n\t\n\t            event.stopPropagation();\n\t            event.stopImmediatePropagation();\n\t            return;\n\t        }\n\t\n\t        var currentSelection = window.getSelection(),\n\t            currentSelectedNode = currentSelection.anchorNode,\n\t            caretAtTheEndOfText = editor.caret.position.atTheEnd(),\n\t            isTextNodeHasParentBetweenContenteditable = false;\n\t\n\t        /**\n\t         * Allow making new <p> in same block by SHIFT+ENTER and forbids to prevent default browser behaviour\n\t         */\n\t        if (event.shiftKey && !enableLineBreaks) {\n\t\n\t            editor.callback.enterPressedOnBlock(editor.content.currentBlock, event);\n\t            event.preventDefault();\n\t            return;\n\t        }\n\t\n\t        /**\n\t         * Workaround situation when caret at the Text node that has some wrapper Elements\n\t         * Split block cant handle this.\n\t         * We need to save default behavior\n\t         */\n\t        isTextNodeHasParentBetweenContenteditable = currentSelectedNode && currentSelectedNode.parentNode.contentEditable != 'true';\n\t\n\t        /**\n\t         * Split blocks when input has several nodes and caret placed in textNode\n\t         */\n\t        if (currentSelectedNode.nodeType == editor.core.nodeTypes.TEXT && !isTextNodeHasParentBetweenContenteditable && !caretAtTheEndOfText) {\n\t\n\t            event.preventDefault();\n\t\n\t            editor.core.log('Splitting Text node...');\n\t\n\t            editor.content.splitBlock(currentInputIndex);\n\t\n\t            /** Show plus button when next input after split is empty*/\n\t            if (!editor.state.inputs[currentInputIndex + 1].textContent.trim()) {\n\t\n\t                editor.toolbar.showPlusButton();\n\t            }\n\t        } else {\n\t\n\t            var islastNode = editor.content.isLastNode(currentSelectedNode);\n\t\n\t            if (islastNode && caretAtTheEndOfText) {\n\t\n\t                event.preventDefault();\n\t                event.stopPropagation();\n\t                event.stopImmediatePropagation();\n\t\n\t                editor.core.log('ENTER clicked in last textNode. Create new BLOCK');\n\t\n\t                editor.content.insertBlock({\n\t                    type: NEW_BLOCK_TYPE,\n\t                    block: editor.tools[NEW_BLOCK_TYPE].render()\n\t                }, true);\n\t\n\t                editor.toolbar.move();\n\t                editor.toolbar.open();\n\t\n\t                /** Show plus button with empty block */\n\t                editor.toolbar.showPlusButton();\n\t            }\n\t        }\n\t\n\t        /** get all inputs after new appending block */\n\t        editor.ui.saveInputs();\n\t    };\n\t\n\t    callbacks.escapeKeyPressed = function (event) {\n\t\n\t        /** Close all toolbar */\n\t        editor.toolbar.close();\n\t\n\t        /** Close toolbox */\n\t        editor.toolbar.toolbox.close();\n\t\n\t        event.preventDefault();\n\t    };\n\t\n\t    /**\n\t    * @param {Event} event\n\t    */\n\t    callbacks.arrowKeyPressed = function () {\n\t\n\t        editor.content.workingNodeChanged();\n\t\n\t        /* Closing toolbar */\n\t        editor.toolbar.close();\n\t        editor.toolbar.move();\n\t    };\n\t\n\t    /**\n\t    * @param {Event} event\n\t    */\n\t    callbacks.defaultKeyPressed = function () {\n\t\n\t        editor.toolbar.close();\n\t\n\t        if (!editor.toolbar.inline.actionsOpened) {\n\t\n\t            editor.toolbar.inline.close();\n\t            editor.content.clearMark();\n\t        }\n\t    };\n\t\n\t    callbacks.redactorClicked = function (event) {\n\t\n\t        callbacks.detectWhenClickedOnFirstLevelBlockArea();\n\t\n\t        editor.content.workingNodeChanged(event.target);\n\t\n\t        editor.ui.saveInputs();\n\t\n\t        var selectedText = editor.toolbar.inline.getSelectionText(),\n\t            firstLevelBlock;\n\t\n\t        /**\n\t         * If selection range took off, then we hide inline toolbar\n\t         */\n\t        if (selectedText.length === 0) {\n\t\n\t            editor.toolbar.inline.close();\n\t        }\n\t\n\t        /** Update current input index in memory when caret focused into existed input */\n\t        if (event.target.contentEditable == 'true') {\n\t\n\t            editor.caret.saveCurrentInputIndex();\n\t        }\n\t\n\t        if (editor.content.currentNode === null) {\n\t\n\t            /**\n\t             * If inputs in redactor does not exits, then we put input index 0 not -1\n\t             */\n\t            var indexOfLastInput = editor.state.inputs.length > 0 ? editor.state.inputs.length - 1 : 0;\n\t\n\t            /** If we have any inputs */\n\t            if (editor.state.inputs.length) {\n\t\n\t                /**\n\t                * @todo Refactor\n\t                */\n\t\n\t                /** getting firstlevel parent of input */\n\t                firstLevelBlock = editor.content.getFirstLevelBlock(editor.state.inputs[indexOfLastInput]);\n\t            }\n\t\n\t            /** If input is empty, then we set caret to the last input */\n\t            if (editor.state.inputs.length && editor.state.inputs[indexOfLastInput].textContent === '' && firstLevelBlock.dataset.tool == editor.settings.initialBlockPlugin) {\n\t\n\t                editor.caret.setToBlock(indexOfLastInput);\n\t            } else {\n\t\n\t                /** Create new input when caret clicked in redactors area */\n\t                var NEW_BLOCK_TYPE = editor.settings.initialBlockPlugin;\n\t\n\t                editor.content.insertBlock({\n\t                    type: NEW_BLOCK_TYPE,\n\t                    block: editor.tools[NEW_BLOCK_TYPE].render()\n\t                });\n\t\n\t                /** If there is no inputs except inserted */\n\t                if (editor.state.inputs.length === 1) {\n\t\n\t                    editor.caret.setToBlock(indexOfLastInput);\n\t                } else {\n\t\n\t                    /** Set caret to this appended input */\n\t                    editor.caret.setToNextBlock(indexOfLastInput);\n\t                }\n\t            }\n\t\n\t            /**\n\t             * Move toolbar to the right position and open\n\t             */\n\t            editor.toolbar.move();\n\t            editor.toolbar.open();\n\t        } else {\n\t\n\t            /**\n\t             * Move toolbar to the new position and open\n\t             */\n\t            editor.toolbar.move();\n\t            editor.toolbar.open();\n\t\n\t            /** Close all panels */\n\t            editor.toolbar.settings.close();\n\t            editor.toolbar.toolbox.close();\n\t        }\n\t\n\t        var inputIsEmpty = !editor.content.currentNode.textContent.trim(),\n\t            currentNodeType = editor.content.currentNode.dataset.tool,\n\t            isInitialType = currentNodeType == editor.settings.initialBlockPlugin;\n\t\n\t        /** Hide plus buttons */\n\t        editor.toolbar.hidePlusButton();\n\t\n\t        /** Mark current block */\n\t        editor.content.markBlock();\n\t\n\t        if (isInitialType && inputIsEmpty) {\n\t\n\t            /** Show plus button */\n\t            editor.toolbar.showPlusButton();\n\t        }\n\t    };\n\t\n\t    /**\n\t     * This method allows to define, is caret in contenteditable element or not.\n\t     * Otherwise, if we get TEXT node from range container, that will means we have input index.\n\t     * In this case we use default browsers behaviour (if plugin allows that) or overwritten action.\n\t     * Therefore, to be sure that we've clicked first-level block area, we should have currentNode, which always\n\t     * specifies to the first-level block. Other cases we just ignore.\n\t     */\n\t    callbacks.detectWhenClickedOnFirstLevelBlockArea = function () {\n\t\n\t        var selection = window.getSelection(),\n\t            anchorNode = selection.anchorNode,\n\t            flag = false;\n\t\n\t        if (selection.rangeCount === 0) {\n\t\n\t            editor.content.editorAreaHightlighted = true;\n\t        } else {\n\t\n\t            if (!editor.core.isDomNode(anchorNode)) {\n\t\n\t                anchorNode = anchorNode.parentNode;\n\t            }\n\t\n\t            /** Already founded, without loop */\n\t            if (anchorNode.contentEditable == 'true') {\n\t\n\t                flag = true;\n\t            }\n\t\n\t            while (anchorNode.contentEditable != 'true') {\n\t\n\t                anchorNode = anchorNode.parentNode;\n\t\n\t                if (anchorNode.contentEditable == 'true') {\n\t\n\t                    flag = true;\n\t                }\n\t\n\t                if (anchorNode == document.body) {\n\t\n\t                    break;\n\t                }\n\t            }\n\t\n\t            /** If editable element founded, flag is \"TRUE\", Therefore we return \"FALSE\" */\n\t            editor.content.editorAreaHightlighted = flag ? false : true;\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Toolbar button click handler\n\t     * @param this - cursor to the button\n\t     */\n\t    callbacks.toolbarButtonClicked = function (event) {\n\t\n\t        var button = this;\n\t\n\t        editor.toolbar.current = button.dataset.type;\n\t\n\t        editor.toolbar.toolbox.toolClicked(event);\n\t        editor.toolbar.close();\n\t    };\n\t\n\t    /** Show or Hide toolbox when plus button is clicked */\n\t    callbacks.plusButtonClicked = function () {\n\t\n\t        if (!editor.nodes.toolbox.classList.contains('opened')) {\n\t\n\t            editor.toolbar.toolbox.open();\n\t        } else {\n\t\n\t            editor.toolbar.toolbox.close();\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Block handlers for KeyDown events\n\t     */\n\t    callbacks.blockKeydown = function (event) {\n\t\n\t        var block = this; // event.target input\n\t\n\t        switch (event.keyCode) {\n\t\n\t            case editor.core.keys.DOWN:\n\t            case editor.core.keys.RIGHT:\n\t                editor.callback.blockRightOrDownArrowPressed();\n\t                break;\n\t\n\t            case editor.core.keys.BACKSPACE:\n\t                editor.callback.backspacePressed(block, event);\n\t                break;\n\t\n\t            case editor.core.keys.UP:\n\t            case editor.core.keys.LEFT:\n\t                editor.callback.blockLeftOrUpArrowPressed();\n\t                break;\n\t\n\t        }\n\t    };\n\t\n\t    /**\n\t     * RIGHT or DOWN keydowns on block\n\t     */\n\t    callbacks.blockRightOrDownArrowPressed = function () {\n\t\n\t        var selection = window.getSelection(),\n\t            inputs = editor.state.inputs,\n\t            focusedNode = selection.anchorNode,\n\t            focusedNodeHolder;\n\t\n\t        /** Check for caret existance */\n\t        if (!focusedNode) {\n\t\n\t            return false;\n\t        }\n\t\n\t        /** Looking for closest (parent) contentEditable element of focused node */\n\t        while (focusedNode.contentEditable != 'true') {\n\t\n\t            focusedNodeHolder = focusedNode.parentNode;\n\t            focusedNode = focusedNodeHolder;\n\t        }\n\t\n\t        /** Input index in DOM level */\n\t        var editableElementIndex = 0;\n\t\n\t        while (focusedNode != inputs[editableElementIndex]) {\n\t\n\t            editableElementIndex++;\n\t        }\n\t\n\t        /**\n\t         * Founded contentEditable element doesn't have childs\n\t         * Or maybe New created block\n\t         */\n\t        if (!focusedNode.textContent) {\n\t\n\t            editor.caret.setToNextBlock(editableElementIndex);\n\t            return;\n\t        }\n\t\n\t        /**\n\t         * Do nothing when caret doesn not reaches the end of last child\n\t         */\n\t        var caretInLastChild = false,\n\t            caretAtTheEndOfText = false;\n\t\n\t        var lastChild, deepestTextnode;\n\t\n\t        lastChild = focusedNode.childNodes[focusedNode.childNodes.length - 1];\n\t\n\t        if (editor.core.isDomNode(lastChild)) {\n\t\n\t            deepestTextnode = editor.content.getDeepestTextNodeFromPosition(lastChild, lastChild.childNodes.length);\n\t        } else {\n\t\n\t            deepestTextnode = lastChild;\n\t        }\n\t\n\t        caretInLastChild = selection.anchorNode == deepestTextnode;\n\t        caretAtTheEndOfText = deepestTextnode.length == selection.anchorOffset;\n\t\n\t        if (!caretInLastChild || !caretAtTheEndOfText) {\n\t\n\t            editor.core.log('arrow [down|right] : caret does not reached the end');\n\t            return false;\n\t        }\n\t\n\t        editor.caret.setToNextBlock(editableElementIndex);\n\t    };\n\t\n\t    /**\n\t     * LEFT or UP keydowns on block\n\t     */\n\t    callbacks.blockLeftOrUpArrowPressed = function () {\n\t\n\t        var selection = window.getSelection(),\n\t            inputs = editor.state.inputs,\n\t            focusedNode = selection.anchorNode,\n\t            focusedNodeHolder;\n\t\n\t        /** Check for caret existance */\n\t        if (!focusedNode) {\n\t\n\t            return false;\n\t        }\n\t\n\t        /**\n\t         * LEFT or UP not at the beginning\n\t         */\n\t        if (selection.anchorOffset !== 0) {\n\t\n\t            return false;\n\t        }\n\t\n\t        /** Looking for parent contentEditable block */\n\t        while (focusedNode.contentEditable != 'true') {\n\t\n\t            focusedNodeHolder = focusedNode.parentNode;\n\t            focusedNode = focusedNodeHolder;\n\t        }\n\t\n\t        /** Input index in DOM level */\n\t        var editableElementIndex = 0;\n\t\n\t        while (focusedNode != inputs[editableElementIndex]) {\n\t\n\t            editableElementIndex++;\n\t        }\n\t\n\t        /**\n\t         * Do nothing if caret is not at the beginning of first child\n\t         */\n\t        var caretInFirstChild = false,\n\t            caretAtTheBeginning = false;\n\t\n\t        var firstChild, deepestTextnode;\n\t\n\t        /**\n\t         * Founded contentEditable element doesn't have childs\n\t         * Or maybe New created block\n\t         */\n\t        if (!focusedNode.textContent) {\n\t\n\t            editor.caret.setToPreviousBlock(editableElementIndex);\n\t            return;\n\t        }\n\t\n\t        firstChild = focusedNode.childNodes[0];\n\t\n\t        if (editor.core.isDomNode(firstChild)) {\n\t\n\t            deepestTextnode = editor.content.getDeepestTextNodeFromPosition(firstChild, 0);\n\t        } else {\n\t\n\t            deepestTextnode = firstChild;\n\t        }\n\t\n\t        caretInFirstChild = selection.anchorNode == deepestTextnode;\n\t        caretAtTheBeginning = selection.anchorOffset === 0;\n\t\n\t        if (caretInFirstChild && caretAtTheBeginning) {\n\t\n\t            editor.caret.setToPreviousBlock(editableElementIndex);\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Callback for enter key pressing in first-level block area\n\t     * @param {Event} event\n\t     */\n\t    callbacks.enterPressedOnBlock = function () {\n\t\n\t        var NEW_BLOCK_TYPE = editor.settings.initialBlockPlugin;\n\t\n\t        editor.content.insertBlock({\n\t            type: NEW_BLOCK_TYPE,\n\t            block: editor.tools[NEW_BLOCK_TYPE].render()\n\t        }, true);\n\t\n\t        editor.toolbar.move();\n\t        editor.toolbar.open();\n\t    };\n\t\n\t    callbacks.backspacePressed = function (block, event) {\n\t\n\t        var currentInputIndex = editor.caret.getCurrentInputIndex(),\n\t            range,\n\t            selectionLength,\n\t            firstLevelBlocksCount;\n\t\n\t        if (block.textContent.trim()) {\n\t\n\t            range = editor.content.getRange();\n\t            selectionLength = range.endOffset - range.startOffset;\n\t\n\t            if (editor.caret.position.atStart() && !selectionLength && editor.state.inputs[currentInputIndex - 1]) {\n\t\n\t                editor.content.mergeBlocks(currentInputIndex);\n\t            } else {\n\t\n\t                return;\n\t            }\n\t        }\n\t\n\t        if (!selectionLength) {\n\t\n\t            block.remove();\n\t        }\n\t\n\t        firstLevelBlocksCount = editor.nodes.redactor.childNodes.length;\n\t\n\t        /**\n\t         * If all blocks are removed\n\t         */\n\t        if (firstLevelBlocksCount === 0) {\n\t\n\t            /** update currentNode variable */\n\t            editor.content.currentNode = null;\n\t\n\t            /** Inserting new empty initial block */\n\t            editor.ui.addInitialBlock();\n\t\n\t            /** Updating inputs state after deleting last block */\n\t            editor.ui.saveInputs();\n\t\n\t            /** Set to current appended block */\n\t            window.setTimeout(function () {\n\t\n\t                editor.caret.setToPreviousBlock(1);\n\t            }, 10);\n\t        } else {\n\t\n\t            if (editor.caret.inputIndex !== 0) {\n\t\n\t                /** Target block is not first */\n\t                editor.caret.setToPreviousBlock(editor.caret.inputIndex);\n\t            } else {\n\t\n\t                /** If we try to delete first block */\n\t                editor.caret.setToNextBlock(editor.caret.inputIndex);\n\t            }\n\t        }\n\t\n\t        editor.toolbar.move();\n\t\n\t        if (!editor.toolbar.opened) {\n\t\n\t            editor.toolbar.open();\n\t        }\n\t\n\t        /** Updating inputs state */\n\t        editor.ui.saveInputs();\n\t\n\t        /** Prevent default browser behaviour */\n\t        event.preventDefault();\n\t    };\n\t\n\t    /**\n\t     * This method is used to observe pasted dirty data.\n\t     *\n\t     * Mutation handlers send to separate observers each mutation (added, changed and so on), which will be\n\t     * passed from handler that sanitizes and replaces data.\n\t     *\n\t     * Probably won't be used\n\t     *\n\t     * @deprecated\n\t     *\n\t     * @param event\n\t     * @private\n\t     */\n\t    callbacks._blockPasteCallback = function () {\n\t\n\t        var currentInputIndex = editor.caret.getCurrentInputIndex();\n\t\n\t        /**\n\t         * create an observer instance\n\t         */\n\t        var observer = new MutationObserver(editor.callback.handleMutationsOnPaste);\n\t\n\t        /**\n\t         * configuration of the observer:\n\t         */\n\t        var config = {\n\t            attributes: true,\n\t            childList: false,\n\t            characterData: false,\n\t            subtree: true\n\t        };\n\t\n\t        // pass in the target node, as well as the observer options\n\t        observer.observe(editor.state.inputs[currentInputIndex], config);\n\t    };\n\t\n\t    /**\n\t     * This method prevents default behaviour.\n\t     *\n\t     * We get from clipboard pasted data, sanitize, make a fragment that contains of this sanitized nodes.\n\t     * Firstly, we need to memorize the caret position. We can do that by getting the range of selection.\n\t     * After all, we insert clear fragment into caret placed position. Then, we should move the caret to the last node\n\t     *\n\t     * @param event\n\t     */\n\t    callbacks.blockPasteCallback = function (event) {\n\t\n\t        /** Prevent default behaviour */\n\t        event.preventDefault();\n\t\n\t        /** Allow paste when event target is editable */\n\t        if (event.target.contentEditable != 'true') {\n\t\n\t            return;\n\t        }\n\t\n\t        /** get html pasted data - dirty data */\n\t        var data = event.clipboardData.getData('text/html') || event.clipboardData.getData('text/plain');\n\t\n\t        /** Temporary DIV that is used to work with childs as arrays item */\n\t        var div = editor.draw.node('DIV', '', {}),\n\t            cleaner = new editor.sanitizer.init(editor.sanitizer.Config.BASIC),\n\t            cleanData,\n\t            fragment;\n\t\n\t        /** Create fragment, that we paste to range after proccesing */\n\t        fragment = document.createDocumentFragment();\n\t\n\t        cleanData = cleaner.clean(data);\n\t\n\t        div.innerHTML = cleanData;\n\t\n\t        var node, lastNode;\n\t\n\t        /**\n\t         * and fill in fragment\n\t         */\n\t        while (node = div.firstChild) {\n\t\n\t            lastNode = fragment.appendChild(node);\n\t        }\n\t\n\t        /**\n\t         * work with selection and range\n\t         */\n\t        var selection, range;\n\t\n\t        selection = window.getSelection();\n\t\n\t        range = selection.getRangeAt(0);\n\t        range.deleteContents();\n\t\n\t        range.insertNode(fragment);\n\t\n\t        /** Preserve the selection */\n\t        if (lastNode) {\n\t\n\t            range = range.cloneRange();\n\t            range.setStartAfter(lastNode);\n\t            range.collapse(true);\n\t            selection.removeAllRanges();\n\t            selection.addRange(range);\n\t        }\n\t    };\n\t\n\t    /**\n\t     * Sends all mutations to paste handler\n\t     */\n\t    callbacks.handleMutationsOnPaste = function (mutations) {\n\t\n\t        var self = this;\n\t\n\t        /**\n\t         * Calling function with context of this function.\n\t         * Also, we should sanitize pasted or changed data one time and ignore\n\t         * changings which makes sanitize method.\n\t         * For that, we need to send Context, MutationObserver.__proto__ that contains\n\t         * observer disconnect method.\n\t         */\n\t        mutations.forEach(function (mutation) {\n\t\n\t            editor.content.paste.call(self, mutation);\n\t        });\n\t    };\n\t\n\t    /**\n\t     * Clicks on block settings button\n\t     */\n\t    callbacks.showSettingsButtonClicked = function () {\n\t\n\t        /**\n\t         * Get type of current block\n\t         * It uses to append settings from tool.settings property.\n\t         * ...\n\t         * Type is stored in data-type attribute on block\n\t         */\n\t        var currentToolType = editor.content.currentNode.dataset.tool;\n\t\n\t        editor.toolbar.settings.toggle(currentToolType);\n\t\n\t        /** Close toolbox when settings button is active */\n\t        editor.toolbar.toolbox.close();\n\t        editor.toolbar.settings.hideRemoveActions();\n\t    };\n\t\n\t    return callbacks;\n\t}({});\n\n/***/ },\n/* 12 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t/**\n\t * Codex Editor Draw module\n\t *\n\t * @author Codex Team\n\t * @version 1.0.\n\t */\n\t\n\tmodule.exports = function (draw) {\n\t\n\t    /**\n\t     * Base editor wrapper\n\t     */\n\t    draw.wrapper = function () {\n\t\n\t        var wrapper = document.createElement('div');\n\t\n\t        wrapper.className += 'codex-editor';\n\t\n\t        return wrapper;\n\t    };\n\t\n\t    /**\n\t     * Content-editable holder\n\t     */\n\t    draw.redactor = function () {\n\t\n\t        var redactor = document.createElement('div');\n\t\n\t        redactor.className += 'ce-redactor';\n\t\n\t        return redactor;\n\t    };\n\t\n\t    draw.ceBlock = function () {\n\t\n\t        var block = document.createElement('DIV');\n\t\n\t        block.className += 'ce_block';\n\t\n\t        return block;\n\t    };\n\t\n\t    /**\n\t     * Empty toolbar with toggler\n\t     */\n\t    draw.toolbar = function () {\n\t\n\t        var bar = document.createElement('div');\n\t\n\t        bar.className += 'ce-toolbar';\n\t\n\t        return bar;\n\t    };\n\t\n\t    draw.toolbarContent = function () {\n\t\n\t        var wrapper = document.createElement('DIV');\n\t\n\t        wrapper.classList.add('ce-toolbar__content');\n\t\n\t        return wrapper;\n\t    };\n\t\n\t    /**\n\t     * Inline toolbar\n\t     */\n\t    draw.inlineToolbar = function () {\n\t\n\t        var bar = document.createElement('DIV');\n\t\n\t        bar.className += 'ce-toolbar-inline';\n\t\n\t        return bar;\n\t    };\n\t\n\t    /**\n\t     * Wrapper for inline toobar buttons\n\t     */\n\t    draw.inlineToolbarButtons = function () {\n\t\n\t        var wrapper = document.createElement('DIV');\n\t\n\t        wrapper.className += 'ce-toolbar-inline__buttons';\n\t\n\t        return wrapper;\n\t    };\n\t\n\t    /**\n\t     * For some actions\n\t     */\n\t    draw.inlineToolbarActions = function () {\n\t\n\t        var wrapper = document.createElement('DIV');\n\t\n\t        wrapper.className += 'ce-toolbar-inline__actions';\n\t\n\t        return wrapper;\n\t    };\n\t\n\t    draw.inputForLink = function () {\n\t\n\t        var input = document.createElement('INPUT');\n\t\n\t        input.type = 'input';\n\t        input.className += 'inputForLink';\n\t        input.placeholder = '  ...';\n\t        input.setAttribute('form', 'defaultForm');\n\t\n\t        input.setAttribute('autofocus', 'autofocus');\n\t\n\t        return input;\n\t    };\n\t\n\t    /**\n\t     * Block with notifications\n\t     */\n\t    draw.alertsHolder = function () {\n\t\n\t        var block = document.createElement('div');\n\t\n\t        block.classList.add('ce_notifications-block');\n\t\n\t        return block;\n\t    };\n\t\n\t    /**\n\t     * @todo Desc\n\t     */\n\t    draw.blockButtons = function () {\n\t\n\t        var block = document.createElement('div');\n\t\n\t        block.className += 'ce-toolbar__actions';\n\t\n\t        return block;\n\t    };\n\t\n\t    /**\n\t     * Block settings panel\n\t     */\n\t    draw.blockSettings = function () {\n\t\n\t        var settings = document.createElement('div');\n\t\n\t        settings.className += 'ce-settings';\n\t\n\t        return settings;\n\t    };\n\t\n\t    draw.defaultSettings = function () {\n\t\n\t        var div = document.createElement('div');\n\t\n\t        div.classList.add('ce-settings_default');\n\t\n\t        return div;\n\t    };\n\t\n\t    draw.pluginsSettings = function () {\n\t\n\t        var div = document.createElement('div');\n\t\n\t        div.classList.add('ce-settings_plugin');\n\t\n\t        return div;\n\t    };\n\t\n\t    draw.plusButton = function () {\n\t\n\t        var button = document.createElement('span');\n\t\n\t        button.className = 'ce-toolbar__plus';\n\t        // button.innerHTML = '<i class=\"ce-icon-plus\"></i>';\n\t\n\t        return button;\n\t    };\n\t\n\t    /**\n\t     * Settings button in toolbar\n\t     */\n\t    draw.settingsButton = function () {\n\t\n\t        var toggler = document.createElement('span');\n\t\n\t        toggler.className = 'ce-toolbar__settings-btn';\n\t\n\t        /** Toggler button*/\n\t        toggler.innerHTML = '<i class=\"ce-icon-cog\"></i>';\n\t\n\t        return toggler;\n\t    };\n\t\n\t    /**\n\t     * Redactor tools wrapper\n\t     */\n\t\n\t    draw.toolbox = function () {\n\t\n\t        var wrapper = document.createElement('div');\n\t\n\t        wrapper.className = 'ce-toolbar__tools';\n\t\n\t        return wrapper;\n\t    };\n\t\n\t    /**\n\t     * @protected\n\t     *\n\t     * Draws tool buttons for toolbox\n\t     *\n\t     * @param {String} type\n\t     * @param {String} classname\n\t     * @returns {Element}\n\t     */\n\t    draw.toolbarButton = function (type, classname) {\n\t\n\t        var button = document.createElement('li'),\n\t            toolIcon = document.createElement('i'),\n\t            toolTitle = document.createElement('span');\n\t\n\t        button.dataset.type = type;\n\t        button.setAttribute('title', type);\n\t\n\t        toolIcon.classList.add(classname);\n\t        toolTitle.classList.add('ce_toolbar_tools--title');\n\t\n\t        button.appendChild(toolIcon);\n\t        button.appendChild(toolTitle);\n\t\n\t        return button;\n\t    };\n\t\n\t    /**\n\t     * @protected\n\t     *\n\t     * Draws tools for inline toolbar\n\t     *\n\t     * @param {String} type\n\t     * @param {String} classname\n\t     */\n\t    draw.toolbarButtonInline = function (type, classname) {\n\t\n\t        var button = document.createElement('BUTTON'),\n\t            toolIcon = document.createElement('I');\n\t\n\t        button.type = 'button';\n\t        button.dataset.type = type;\n\t        toolIcon.classList.add(classname);\n\t\n\t        button.appendChild(toolIcon);\n\t\n\t        return button;\n\t    };\n\t\n\t    /**\n\t     * Redactor block\n\t     */\n\t    draw.block = function (tagName, content) {\n\t\n\t        var node = document.createElement(tagName);\n\t\n\t        node.innerHTML = content || '';\n\t\n\t        return node;\n\t    };\n\t\n\t    /**\n\t     * Creates Node with passed tagName and className\n\t     * @param {string}  tagName\n\t     * @param {string} className\n\t     * @param {object} properties - allow to assign properties\n\t     */\n\t    draw.node = function (tagName, className, properties) {\n\t\n\t        var el = document.createElement(tagName);\n\t\n\t        if (className) el.className = className;\n\t\n\t        if (properties) {\n\t\n\t            for (var name in properties) {\n\t\n\t                el[name] = properties[name];\n\t            }\n\t        }\n\t\n\t        return el;\n\t    };\n\t\n\t    draw.unavailableBlock = function (data) {\n\t\n\t        var wrapper = document.createElement('DIV');\n\t        wrapper.classList.add('unavailableBlock');\n\t        wrapper.dataset.cacheId = data;\n\t\n\t        return wrapper;\n\t    };\n\t\n\t    return draw;\n\t}({});\n\n/***/ },\n/* 13 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t/**\n\t * Codex Editor Caret Module\n\t *\n\t * @author Codex Team\n\t * @version 1.0\n\t */\n\tvar editor = codex.editor;\n\t\n\tmodule.exports = function (caret) {\n\t\n\t    /**\n\t     * @var {int} InputIndex - editable element in DOM\n\t     */\n\t    caret.inputIndex = null;\n\t\n\t    /**\n\t     * @var {int} offset - caret position in a text node.\n\t     */\n\t    caret.offset = null;\n\t\n\t    /**\n\t     * @var {int} focusedNodeIndex - we get index of child node from first-level block\n\t     */\n\t    caret.focusedNodeIndex = null;\n\t\n\t    /**\n\t     * Creates Document Range and sets caret to the element.\n\t     * @protected\n\t     * @uses caret.save  if you need to save caret position\n\t     * @param {Element} el - Changed Node.\n\t     */\n\t    caret.set = function (el, index, offset) {\n\t\n\t        offset = offset || caret.offset || 0;\n\t        index = index || caret.focusedNodeIndex || 0;\n\t\n\t        var childs = el.childNodes,\n\t            nodeToSet;\n\t\n\t        if (childs.length === 0) {\n\t\n\t            nodeToSet = el;\n\t        } else {\n\t\n\t            nodeToSet = childs[index];\n\t        }\n\t\n\t        /** If Element is INPUT */\n\t        if (el.tagName == 'INPUT') {\n\t\n\t            el.focus();\n\t            return;\n\t        }\n\t\n\t        if (editor.core.isDomNode(nodeToSet)) {\n\t\n\t            nodeToSet = editor.content.getDeepestTextNodeFromPosition(nodeToSet, nodeToSet.childNodes.length);\n\t        }\n\t\n\t        var range = document.createRange(),\n\t            selection = window.getSelection();\n\t\n\t        window.setTimeout(function () {\n\t\n\t            range.setStart(nodeToSet, offset);\n\t            range.setEnd(nodeToSet, offset);\n\t\n\t            selection.removeAllRanges();\n\t            selection.addRange(range);\n\t\n\t            editor.caret.saveCurrentInputIndex();\n\t        }, 20);\n\t    };\n\t\n\t    /**\n\t     * @protected\n\t     * Updates index of input and saves it in caret object\n\t     */\n\t    caret.saveCurrentInputIndex = function () {\n\t\n\t        /** Index of Input that we paste sanitized content */\n\t        var selection = window.getSelection(),\n\t            inputs = editor.state.inputs,\n\t            focusedNode = selection.anchorNode,\n\t            focusedNodeHolder;\n\t\n\t        if (!focusedNode) {\n\t\n\t            return;\n\t        }\n\t\n\t        /** Looking for parent contentEditable block */\n\t        while (focusedNode.contentEditable != 'true') {\n\t\n\t            focusedNodeHolder = focusedNode.parentNode;\n\t            focusedNode = focusedNodeHolder;\n\t        }\n\t\n\t        /** Input index in DOM level */\n\t        var editableElementIndex = 0;\n\t\n\t        while (focusedNode != inputs[editableElementIndex]) {\n\t\n\t            editableElementIndex++;\n\t        }\n\t\n\t        caret.inputIndex = editableElementIndex;\n\t    };\n\t\n\t    /**\n\t     * Returns current input index (caret object)\n\t     */\n\t    caret.getCurrentInputIndex = function () {\n\t\n\t        return caret.inputIndex;\n\t    };\n\t\n\t    /**\n\t     * @param {int} index - index of first-level block after that we set caret into next input\n\t     */\n\t    caret.setToNextBlock = function (index) {\n\t\n\t        var inputs = editor.state.inputs,\n\t            nextInput = inputs[index + 1];\n\t\n\t        if (!nextInput) {\n\t\n\t            editor.core.log('We are reached the end');\n\t            return;\n\t        }\n\t\n\t        /**\n\t         * When new Block created or deleted content of input\n\t         * We should add some text node to set caret\n\t         */\n\t        if (!nextInput.childNodes.length) {\n\t\n\t            var emptyTextElement = document.createTextNode('');\n\t\n\t            nextInput.appendChild(emptyTextElement);\n\t        }\n\t\n\t        editor.caret.inputIndex = index + 1;\n\t        editor.caret.set(nextInput, 0, 0);\n\t        editor.content.workingNodeChanged(nextInput);\n\t    };\n\t\n\t    /**\n\t     * @param {int} index - index of target input.\n\t     * Sets caret to input with this index\n\t     */\n\t    caret.setToBlock = function (index) {\n\t\n\t        var inputs = editor.state.inputs,\n\t            targetInput = inputs[index];\n\t\n\t        if (!targetInput) {\n\t\n\t            return;\n\t        }\n\t\n\t        /**\n\t         * When new Block created or deleted content of input\n\t         * We should add some text node to set caret\n\t         */\n\t        if (!targetInput.childNodes.length) {\n\t\n\t            var emptyTextElement = document.createTextNode('');\n\t\n\t            targetInput.appendChild(emptyTextElement);\n\t        }\n\t\n\t        editor.caret.inputIndex = index;\n\t        editor.caret.set(targetInput, 0, 0);\n\t        editor.content.workingNodeChanged(targetInput);\n\t    };\n\t\n\t    /**\n\t     * @param {int} index - index of input\n\t     */\n\t    caret.setToPreviousBlock = function (index) {\n\t\n\t        index = index || 0;\n\t\n\t        var inputs = editor.state.inputs,\n\t            previousInput = inputs[index - 1],\n\t            lastChildNode,\n\t            lengthOfLastChildNode,\n\t            emptyTextElement;\n\t\n\t        if (!previousInput) {\n\t\n\t            editor.core.log('We are reached first node');\n\t            return;\n\t        }\n\t\n\t        lastChildNode = editor.content.getDeepestTextNodeFromPosition(previousInput, previousInput.childNodes.length);\n\t        lengthOfLastChildNode = lastChildNode.length;\n\t\n\t        /**\n\t         * When new Block created or deleted content of input\n\t         * We should add some text node to set caret\n\t         */\n\t        if (!previousInput.childNodes.length) {\n\t\n\t            emptyTextElement = document.createTextNode('');\n\t            previousInput.appendChild(emptyTextElement);\n\t        }\n\t        editor.caret.inputIndex = index - 1;\n\t        editor.caret.set(previousInput, previousInput.childNodes.length - 1, lengthOfLastChildNode);\n\t        editor.content.workingNodeChanged(inputs[index - 1]);\n\t    };\n\t\n\t    caret.position = {\n\t\n\t        atStart: function atStart() {\n\t\n\t            var selection = window.getSelection(),\n\t                anchorOffset = selection.anchorOffset,\n\t                anchorNode = selection.anchorNode,\n\t                firstLevelBlock = editor.content.getFirstLevelBlock(anchorNode),\n\t                pluginsRender = firstLevelBlock.childNodes[0];\n\t\n\t            if (!editor.core.isDomNode(anchorNode)) {\n\t\n\t                anchorNode = anchorNode.parentNode;\n\t            }\n\t\n\t            var isFirstNode = anchorNode === pluginsRender.childNodes[0],\n\t                isOffsetZero = anchorOffset === 0;\n\t\n\t            return isFirstNode && isOffsetZero;\n\t        },\n\t\n\t        atTheEnd: function atTheEnd() {\n\t\n\t            var selection = window.getSelection(),\n\t                anchorOffset = selection.anchorOffset,\n\t                anchorNode = selection.anchorNode;\n\t\n\t            /** Caret is at the end of input */\n\t            return !anchorNode || !anchorNode.length || anchorOffset === anchorNode.length;\n\t        }\n\t    };\n\t\n\t    return caret;\n\t}({});\n\n/***/ },\n/* 14 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\t/**\n\t * Codex Editor Notification Module\n\t *\n\t * @author Codex Team\n\t * @version 1.0\n\t */\n\tvar editor = codex.editor;\n\t\n\tmodule.exports = function (notifications) {\n\t\n\t    /**\n\t     * Error notificator. Shows block with message\n\t     * @protected\n\t     */\n\t    notifications.errorThrown = function (errorMsg, event) {\n\t\n\t        editor.notifications.send('This action is not available currently', event.type, false);\n\t    };\n\t\n\t    /**\n\t     * Appends notification with different types\n\t     * @param message {string} - Error or alert message\n\t     * @param type {string} - Type of message notification. Ex: Error, Warning, Danger ...\n\t     * @param append {boolean} - can be True or False when notification should be inserted after\n\t     */\n\t    notifications.send = function (message, type, append) {\n\t\n\t        var notification = editor.draw.block('div');\n\t\n\t        notification.textContent = message;\n\t        notification.classList.add('ce_notification-item', 'ce_notification-' + type, 'flipInX');\n\t\n\t        if (!append) {\n\t\n\t            editor.nodes.notifications.innerHTML = '';\n\t        }\n\t\n\t        editor.nodes.notifications.appendChild(notification);\n\t\n\t        window.setTimeout(function () {\n\t\n\t            notification.remove();\n\t        }, 3000);\n\t    };\n\t\n\t    return notifications;\n\t}({});\n\n/***/ },\n/* 15 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\t/**\n\t * Codex Editor Parser Module\n\t *\n\t * @author Codex Team\n\t * @version 1.1\n\t */\n\tvar editor = codex.editor;\n\t\n\tmodule.exports = function (parser) {\n\t\n\t    /** inserting text */\n\t    parser.insertPastedContent = function (blockType, tag) {\n\t\n\t        editor.content.insertBlock({\n\t            type: blockType.type,\n\t            block: blockType.render({\n\t                text: tag.innerHTML\n\t            })\n\t        });\n\t    };\n\t\n\t    /**\n\t     * Check DOM node for display style: separated block or child-view\n\t     */\n\t    parser.isFirstLevelBlock = function (node) {\n\t\n\t        return node.nodeType == editor.core.nodeTypes.TAG && node.classList.contains(editor.ui.className.BLOCK_CLASSNAME);\n\t    };\n\t\n\t    return parser;\n\t}({});\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t/**\n\t * Codex Sanitizer\n\t */\n\t\n\tvar janitor = __webpack_require__(17);\n\t\n\tmodule.exports = function (sanitizer) {\n\t\n\t    /**\n\t     * Basic config\n\t     */\n\t    var Config = {\n\t\n\t        BASIC: {\n\t\n\t            tags: {\n\t                p: {},\n\t                a: {\n\t                    href: true,\n\t                    target: '_blank',\n\t                    rel: 'nofollow'\n\t                },\n\t                i: {},\n\t                b: {},\n\t                strong: {},\n\t                em: {},\n\t                span: {}\n\t            }\n\t        }\n\t    };\n\t\n\t    sanitizer.Config = Config;\n\t\n\t    sanitizer.init = janitor;\n\t\n\t    return sanitizer;\n\t}({});\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (root, factory) {\n\t  if (true) {\n\t    !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t  } else if (typeof exports === 'object') {\n\t    module.exports = factory();\n\t  } else {\n\t    root.HTMLJanitor = factory();\n\t  }\n\t}(this, function () {\n\t\n\t  /**\n\t   * @param {Object} config.tags Dictionary of allowed tags.\n\t   * @param {boolean} config.keepNestedBlockElements Default false.\n\t   */\n\t  function HTMLJanitor(config) {\n\t\n\t    var tagDefinitions = config['tags'];\n\t    var tags = Object.keys(tagDefinitions);\n\t\n\t    var validConfigValues = tags\n\t      .map(function(k) { return typeof tagDefinitions[k]; })\n\t      .every(function(type) { return type === 'object' || type === 'boolean' || type === 'function'; });\n\t\n\t    if(!validConfigValues) {\n\t      throw new Error(\"The configuration was invalid\");\n\t    }\n\t\n\t    this.config = config;\n\t  }\n\t\n\t  // TODO: not exhaustive?\n\t  var blockElementNames = ['P', 'LI', 'TD', 'TH', 'DIV', 'H1', 'H2', 'H3', 'H4', 'H5', 'H6', 'PRE'];\n\t  function isBlockElement(node) {\n\t    return blockElementNames.indexOf(node.nodeName) !== -1;\n\t  }\n\t\n\t  var inlineElementNames = ['A', 'B', 'STRONG', 'I', 'EM', 'SUB', 'SUP', 'U', 'STRIKE'];\n\t  function isInlineElement(node) {\n\t    return inlineElementNames.indexOf(node.nodeName) !== -1;\n\t  }\n\t\n\t  HTMLJanitor.prototype.clean = function (html) {\n\t    var sandbox = document.createElement('div');\n\t    sandbox.innerHTML = html;\n\t\n\t    this._sanitize(sandbox);\n\t\n\t    return sandbox.innerHTML;\n\t  };\n\t\n\t  HTMLJanitor.prototype._sanitize = function (parentNode) {\n\t    var treeWalker = createTreeWalker(parentNode);\n\t    var node = treeWalker.firstChild();\n\t    if (!node) { return; }\n\t\n\t    do {\n\t      // Ignore nodes that have already been sanitized\n\t      if (node._sanitized) {\n\t        continue;\n\t      }\n\t\n\t      if (node.nodeType === Node.TEXT_NODE) {\n\t        // If this text node is just whitespace and the previous or next element\n\t        // sibling is a block element, remove it\n\t        // N.B.: This heuristic could change. Very specific to a bug with\n\t        // `contenteditable` in Firefox: http://jsbin.com/EyuKase/1/edit?js,output\n\t        // FIXME: make this an option?\n\t        if (node.data.trim() === ''\n\t            && ((node.previousElementSibling && isBlockElement(node.previousElementSibling))\n\t                 || (node.nextElementSibling && isBlockElement(node.nextElementSibling)))) {\n\t          parentNode.removeChild(node);\n\t          this._sanitize(parentNode);\n\t          break;\n\t        } else {\n\t          continue;\n\t        }\n\t      }\n\t\n\t      // Remove all comments\n\t      if (node.nodeType === Node.COMMENT_NODE) {\n\t        parentNode.removeChild(node);\n\t        this._sanitize(parentNode);\n\t        break;\n\t      }\n\t\n\t      var isInline = isInlineElement(node);\n\t      var containsBlockElement;\n\t      if (isInline) {\n\t        containsBlockElement = Array.prototype.some.call(node.childNodes, isBlockElement);\n\t      }\n\t\n\t      // Block elements should not be nested (e.g. <li><p>...); if\n\t      // they are, we want to unwrap the inner block element.\n\t      var isNotTopContainer = !! parentNode.parentNode;\n\t      var isNestedBlockElement =\n\t            isBlockElement(parentNode) &&\n\t            isBlockElement(node) &&\n\t            isNotTopContainer;\n\t\n\t      var nodeName = node.nodeName.toLowerCase();\n\t\n\t      var allowedAttrs = getAllowedAttrs(this.config, nodeName, node);\n\t\n\t      var isInvalid = isInline && containsBlockElement;\n\t\n\t      // Drop tag entirely according to the whitelist *and* if the markup\n\t      // is invalid.\n\t      if (isInvalid || shouldRejectNode(node, allowedAttrs)\n\t          || (!this.config.keepNestedBlockElements && isNestedBlockElement)) {\n\t        // Do not keep the inner text of SCRIPT/STYLE elements.\n\t        if (! (node.nodeName === 'SCRIPT' || node.nodeName === 'STYLE')) {\n\t          while (node.childNodes.length > 0) {\n\t            parentNode.insertBefore(node.childNodes[0], node);\n\t          }\n\t        }\n\t        parentNode.removeChild(node);\n\t\n\t        this._sanitize(parentNode);\n\t        break;\n\t      }\n\t\n\t      // Sanitize attributes\n\t      for (var a = 0; a < node.attributes.length; a += 1) {\n\t        var attr = node.attributes[a];\n\t\n\t        if (shouldRejectAttr(attr, allowedAttrs, node)) {\n\t          node.removeAttribute(attr.name);\n\t          // Shift the array to continue looping.\n\t          a = a - 1;\n\t        }\n\t      }\n\t\n\t      // Sanitize children\n\t      this._sanitize(node);\n\t\n\t      // Mark node as sanitized so it's ignored in future runs\n\t      node._sanitized = true;\n\t    } while ((node = treeWalker.nextSibling()));\n\t  };\n\t\n\t  function createTreeWalker(node) {\n\t    return document.createTreeWalker(node,\n\t                                     NodeFilter.SHOW_TEXT | NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT,\n\t                                     null, false);\n\t  }\n\t\n\t  function getAllowedAttrs(config, nodeName, node){\n\t    if (typeof config.tags[nodeName] === 'function') {\n\t      return config.tags[nodeName](node);\n\t    } else {\n\t      return config.tags[nodeName];\n\t    }\n\t  }\n\t\n\t  function shouldRejectNode(node, allowedAttrs){\n\t    if (typeof allowedAttrs === 'undefined') {\n\t      return true;\n\t    } else if (typeof allowedAttrs === 'boolean') {\n\t      return !allowedAttrs;\n\t    }\n\t\n\t    return false;\n\t  }\n\t\n\t  function shouldRejectAttr(attr, allowedAttrs, node){\n\t    var attrName = attr.name.toLowerCase();\n\t\n\t    if (allowedAttrs === true){\n\t      return false;\n\t    } else if (typeof allowedAttrs[attrName] === 'function'){\n\t      return !allowedAttrs[attrName](attr.value, node);\n\t    } else if (typeof allowedAttrs[attrName] === 'undefined'){\n\t      return true;\n\t    } else if (allowedAttrs[attrName] === false) {\n\t      return true;\n\t    } else if (typeof allowedAttrs[attrName] === 'string') {\n\t      return (allowedAttrs[attrName] !== attr.value);\n\t    }\n\t\n\t    return false;\n\t  }\n\t\n\t  return HTMLJanitor;\n\t\n\t}));\n\n\n/***/ }\n/******/ ]);\n\n\n// WEBPACK FOOTER //\n// codex-editor.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 76ee70c804ca96615825","/**\n *\n * Codex Editor\n *\n * @author Codex Team\n */\n\nmodule.exports = (function (editor) {\n\n    'use strict';\n\n    editor.version = VERSION;\n\n    var init = function () {\n\n        editor.core          = require('./modules/core');\n        editor.ui            = require('./modules/ui');\n        editor.transport     = require('./modules/transport');\n        editor.renderer      = require('./modules/renderer');\n        editor.saver         = require('./modules/saver');\n        editor.content       = require('./modules/content');\n        editor.toolbar       = require('./modules/toolbar/toolbar');\n        editor.callback      = require('./modules/callbacks');\n        editor.draw          = require('./modules/draw');\n        editor.caret         = require('./modules/caret');\n        editor.notifications = require('./modules/notifications');\n        editor.parser        = require('./modules/parser');\n        editor.sanitizer     = require('./modules/sanitizer');\n\n    };\n\n    /**\n     * @public\n     *\n     * holds initial settings\n     */\n    editor.settings = {\n        tools     : ['paragraph', 'header', 'picture', 'list', 'quote', 'code', 'twitter', 'instagram', 'smile'],\n        textareaId: 'codex-editor',\n        uploadImagesUrl: '/editor/transport/',\n\n        // Type of block showing on empty editor\n        initialBlockPlugin: 'paragraph'\n    };\n\n    /**\n     * public\n     *\n     * Static nodes\n     */\n    editor.nodes = {\n        textarea          : null,\n        wrapper           : null,\n        toolbar           : null,\n        inlineToolbar     : {\n            wrapper : null,\n            buttons : null,\n            actions : null\n        },\n        toolbox           : null,\n        notifications     : null,\n        plusButton        : null,\n        showSettingsButton: null,\n        showTrashButton   : null,\n        blockSettings     : null,\n        pluginSettings    : null,\n        defaultSettings   : null,\n        toolbarButtons    : {}, // { type : DomEl, ... }\n        redactor          : null\n    };\n\n    /**\n     * @public\n     *\n     * Output state\n     */\n    editor.state = {\n        jsonOutput  : [],\n        blocks      : [],\n        ArrayOfCachedData : [],\n        inputs      : []\n    };\n\n    /**\n    * @public\n    * Editor plugins\n    */\n    editor.tools = {};\n\n    /**\n     * Initialization\n     * @uses Promise cEditor.core.prepare\n     * @param {} userSettings are :\n     *          - tools [],\n     *          - textareaId String\n     *          ...\n     *\n     * Load user defined tools\n     * Tools must contain this important objects :\n     *  @param {String} type - this is a type of plugin. It can be used as plugin name\n     *  @param {String} iconClassname - this a icon in toolbar\n     *  @param {Object} make - what should plugin do, when it is clicked\n     *  @param {Object} appendCallback - callback after clicking\n     *  @param {Element} settings - what settings does it have\n     *  @param {Object} render - plugin get JSON, and should return HTML\n     *  @param {Object} save - plugin gets HTML content, returns JSON\n     *  @param {Boolean} displayInToolbox - will be displayed in toolbox. Default value is TRUE\n     *  @param {Boolean} enableLineBreaks - inserts new block or break lines. Default value is FALSE\n     *\n     * @example\n     *   -  type             : 'header',\n     *   -  iconClassname    : 'ce-icon-header',\n     *   -  make             : headerTool.make,\n     *   -  appendCallback   : headerTool.appendCallback,\n     *   -  settings         : headerTool.makeSettings(),\n     *   -  render           : headerTool.render,\n     *   -  save             : headerTool.save,\n     *   -  displayInToolbox : true,\n     *   -  enableLineBreaks : false\n     */\n    editor.start = function (userSettings) {\n\n        init();\n\n        editor.core.prepare(userSettings)\n\n        // If all ok, make UI, bind events and parse initial-content\n            .then(editor.ui.make)\n            .then(editor.ui.addTools)\n            .then(editor.ui.bindEvents)\n            .then(editor.ui.preparePlugins)\n            .then(editor.transport.prepare)\n            .then(editor.renderer.makeBlocksFromData)\n            .then(editor.ui.saveInputs)\n            .catch(function (error) {\n\n                editor.core.log('Initialization failed with error: %o', 'warn', error);\n\n            });\n\n    };\n\n    return editor;\n\n})({});\n\n\n// WEBPACK FOOTER //\n// ./codex.js","/**\n * Codex Editor Core\n *\n * @author Codex Team\n * @version 1.1.2\n */\n\nlet editor = codex.editor;\n\nmodule.exports = (function (core) {\n\n    /**\n     * @public\n     *\n     * Editor preparing method\n     * @return Promise\n     */\n    core.prepare = function (userSettings) {\n\n        return new Promise(function (resolve, reject) {\n\n            if ( userSettings ) {\n\n                editor.settings.tools = userSettings.tools || editor.settings.tools;\n\n            }\n\n            if (userSettings.data) {\n\n                editor.state.blocks = userSettings.data;\n\n            }\n\n            if (userSettings.initialBlockPlugin) {\n\n                editor.settings.initialBlockPlugin = userSettings.initialBlockPlugin;\n\n            }\n\n            if (userSettings.uploadImagesUrl) {\n\n                editor.settings.uploadImagesUrl = userSettings.uploadImagesUrl;\n\n            }\n\n            editor.nodes.textarea = document.getElementById(userSettings.textareaId || editor.settings.textareaId);\n\n            if (typeof editor.nodes.textarea === undefined || editor.nodes.textarea === null) {\n\n                reject(Error(\"Textarea wasn't found by ID: #\" + userSettings.textareaId));\n\n            } else {\n\n                resolve();\n\n            }\n\n        });\n\n    };\n\n    /**\n     * Logging method\n     * @param type = ['log', 'info', 'warn']\n     */\n    core.log = function (msg, type, arg) {\n\n        type = type || 'log';\n\n        if (!arg) {\n\n            arg  = msg || 'undefined';\n            msg  = '[codex-editor]:      %o';\n\n        } else {\n\n            msg  = '[codex-editor]:      ' + msg;\n\n        }\n\n        try{\n\n            if ( 'console' in window && window.console[ type ] ) {\n\n                if ( arg ) window.console[ type ]( msg, arg );\n                else window.console[ type ]( msg );\n\n            }\n\n        }catch(e) {}\n\n    };\n\n    /**\n     * @protected\n     *\n     * Helper for insert one element after another\n     */\n    core.insertAfter = function (target, element) {\n\n        target.parentNode.insertBefore(element, target.nextSibling);\n\n    };\n\n    /**\n     * @const\n     *\n     * Readable DOM-node types map\n     */\n    core.nodeTypes = {\n        TAG     : 1,\n        TEXT    : 3,\n        COMMENT : 8\n    };\n\n    /**\n     * @const\n     * Readable keys map\n     */\n    core.keys = { BACKSPACE: 8, TAB: 9, ENTER: 13, SHIFT: 16, CTRL: 17, ALT: 18, ESC: 27, SPACE: 32, LEFT: 37, UP: 38, DOWN: 40, RIGHT: 39, DELETE: 46, META: 91 };\n\n    /**\n     * @protected\n     *\n     * Check object for DOM node\n     */\n    core.isDomNode = function (el) {\n\n        return el && typeof el === 'object' && el.nodeType && el.nodeType == this.nodeTypes.TAG;\n\n    };\n\n    /**\n     * Native Ajax\n     */\n    core.ajax = function (data) {\n\n        if (!data || !data.url) {\n\n            return;\n\n        }\n\n        var XMLHTTP          = window.XMLHttpRequest ? new XMLHttpRequest() : new ActiveXObject('Microsoft.XMLHTTP'),\n            successFunction = function () {},\n            params = '',\n            obj;\n\n        data.async           = true;\n        data.type            = data.type || 'GET';\n        data.data            = data.data || '';\n        data['content-type'] = data['content-type'] || 'application/json; charset=utf-8';\n        successFunction     = data.success || successFunction ;\n\n        if (data.type == 'GET' && data.data) {\n\n            data.url = /\\?/.test(data.url) ? data.url + '&' + data.data : data.url + '?' + data.data;\n\n        } else {\n\n            for(obj in data.data) {\n\n                params += (obj + '=' + encodeURIComponent(data.data[obj]) + '&');\n\n            }\n\n        }\n\n        if (data.withCredentials) {\n\n            XMLHTTP.withCredentials = true;\n\n        }\n\n        if (data.beforeSend && typeof data.beforeSend == 'function') {\n\n            data.beforeSend.call();\n\n        }\n\n        XMLHTTP.open( data.type, data.url, data.async );\n        XMLHTTP.setRequestHeader('X-Requested-With', 'XMLHttpRequest');\n        XMLHTTP.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');\n\n        XMLHTTP.onreadystatechange = function () {\n\n            if (XMLHTTP.readyState == 4 && XMLHTTP.status == 200) {\n\n                successFunction(XMLHTTP.responseText);\n\n            }\n\n        };\n\n        XMLHTTP.send(params);\n\n    };\n\n    /**\n    * Appends script to head of document\n    * @return Promise\n    */\n    core.importScript = function (scriptPath, instanceName) {\n\n        return new Promise(function (resolve, reject) {\n\n            const instancePrefix = 'cdx-script-';\n\n            let script;\n\n            /** Script is already loaded */\n            if ( !instanceName ) {\n\n                reject('Instance name is missed');\n\n            } else if ( document.getElementById(instancePrefix + instanceName) ) {\n\n                resolve(scriptPath);\n\n            }\n\n            script = document.createElement('SCRIPT');\n            script.async = true;\n            script.defer = true;\n            script.id = instancePrefix + instanceName;\n\n            script.onload = function () {\n\n                resolve(scriptPath);\n\n            };\n\n            script.onerror = function () {\n\n                reject(scriptPath);\n\n            };\n\n            script.src = scriptPath;\n            document.head.appendChild(script);\n\n        });\n\n    };\n\n    return core;\n\n})({});\n\n\n// WEBPACK FOOTER //\n// ./modules/core.js","/**\n * Codex Editor UI module\n *\n * @author Codex Team\n * @version 1.1\n */\n\nlet editor = codex.editor;\n\nmodule.exports = (function (ui) {\n\n    /**\n     * Basic editor classnames\n     */\n    ui.className = {\n\n        /**\n         * @const {string} BLOCK_CLASSNAME - redactor blocks name\n         */\n        BLOCK_CLASSNAME : 'ce-block',\n\n        /**\n         * @const {String} wrapper for plugins content\n         */\n        BLOCK_CONTENT : 'ce-block__content',\n\n        /**\n         * @const {String} BLOCK_STRETCHED - makes block stretched\n         */\n        BLOCK_STRETCHED : 'ce-block--stretched',\n\n        /**\n         * @const {String} BLOCK_HIGHLIGHTED - adds background\n         */\n        BLOCK_HIGHLIGHTED : 'ce-block--focused',\n\n        /**\n         * @const {String} - highlights covered blocks\n         */\n        BLOCK_IN_FEED_MODE : 'ce-block--feed-mode',\n\n        /**\n         * @const {String} - for all default settings\n         */\n        SETTINGS_ITEM : 'ce-settings__item'\n\n    };\n\n    /**\n     * @protected\n     *\n     * Making main interface\n     */\n    ui.make = function () {\n\n        var wrapper,\n            toolbar,\n            toolbarContent,\n            redactor,\n            notifications,\n            blockButtons,\n            blockSettings,\n            showSettingsButton,\n            showTrashButton,\n            toolbox,\n            plusButton;\n\n        /** Make editor wrapper */\n        wrapper = editor.draw.wrapper();\n\n        /** Append editor wrapper after initial textarea */\n        editor.core.insertAfter(editor.nodes.textarea, wrapper);\n\n        /** Append block with notifications to the document */\n        notifications = editor.draw.alertsHolder();\n        editor.nodes.notifications = document.body.appendChild(notifications);\n\n        /** Make toolbar and content-editable redactor */\n        toolbar               = editor.draw.toolbar();\n        toolbarContent        = editor.draw.toolbarContent();\n        plusButton            = editor.draw.plusButton();\n        showSettingsButton    = editor.draw.settingsButton();\n        showTrashButton       = editor.toolbar.settings.makeRemoveBlockButton();\n        blockSettings         = editor.draw.blockSettings();\n        blockButtons          = editor.draw.blockButtons();\n        toolbox               = editor.draw.toolbox();\n        redactor              = editor.draw.redactor();\n\n        /** settings */\n        var defaultSettings = editor.draw.defaultSettings(),\n            pluginSettings  = editor.draw.pluginsSettings();\n\n        /** Add default and plugins settings */\n        blockSettings.appendChild(pluginSettings);\n        blockSettings.appendChild(defaultSettings);\n\n        /** Make blocks buttons\n         * This block contains settings button and remove block button\n         */\n        blockButtons.appendChild(showSettingsButton);\n        blockButtons.appendChild(showTrashButton);\n        blockButtons.appendChild(blockSettings);\n\n        /** Append plus button */\n        toolbarContent.appendChild(plusButton);\n\n        /** Appending toolbar tools */\n        toolbarContent.appendChild(toolbox);\n\n        /** Appending first-level block buttons */\n        toolbar.appendChild(blockButtons);\n\n        /** Append toolbarContent to toolbar */\n        toolbar.appendChild(toolbarContent);\n\n        wrapper.appendChild(toolbar);\n\n        wrapper.appendChild(redactor);\n\n        /** Save created ui-elements to static nodes state */\n        editor.nodes.wrapper            = wrapper;\n        editor.nodes.toolbar            = toolbar;\n        editor.nodes.plusButton         = plusButton;\n        editor.nodes.toolbox            = toolbox;\n        editor.nodes.blockSettings      = blockSettings;\n        editor.nodes.pluginSettings     = pluginSettings;\n        editor.nodes.defaultSettings    = defaultSettings;\n        editor.nodes.showSettingsButton = showSettingsButton;\n        editor.nodes.showTrashButton    = showTrashButton;\n\n        editor.nodes.redactor = redactor;\n\n        /** Make container for inline toolbar */\n        editor.ui.makeInlineToolbar();\n\n        /** fill in default settings */\n        editor.toolbar.settings.addDefaultSettings();\n\n    };\n\n    ui.makeInlineToolbar = function () {\n\n        var container = editor.draw.inlineToolbar();\n\n        /** Append to redactor new inline block */\n        editor.nodes.inlineToolbar.wrapper = container;\n\n        /** Draw toolbar buttons */\n        editor.nodes.inlineToolbar.buttons = editor.draw.inlineToolbarButtons();\n\n        /** Buttons action or settings */\n        editor.nodes.inlineToolbar.actions = editor.draw.inlineToolbarActions();\n\n        /** Append to inline toolbar buttons as part of it */\n        editor.nodes.inlineToolbar.wrapper.appendChild(editor.nodes.inlineToolbar.buttons);\n        editor.nodes.inlineToolbar.wrapper.appendChild(editor.nodes.inlineToolbar.actions);\n\n        editor.nodes.wrapper.appendChild(editor.nodes.inlineToolbar.wrapper);\n\n    };\n\n    /**\n     * @private\n     * Append tools passed in editor.tools\n     */\n    ui.addTools = function () {\n\n        var tool,\n            toolName,\n            toolButton;\n\n        for ( toolName in editor.settings.tools ) {\n\n            tool = editor.settings.tools[toolName];\n\n            editor.tools[toolName] = tool;\n\n            if (!tool.iconClassname) {\n\n                editor.core.log('Toolbar icon classname missed. Tool %o skipped', 'warn', toolName);\n                continue;\n\n            }\n\n            if (typeof tool.render != 'function') {\n\n                editor.core.log('render method missed. Tool %o skipped', 'warn', toolName);\n                continue;\n\n            }\n\n            if (!tool.displayInToolbox) {\n\n                continue;\n\n            } else {\n\n                /** if tools is for toolbox */\n                toolButton = editor.draw.toolbarButton(toolName, tool.iconClassname);\n\n                editor.nodes.toolbox.appendChild(toolButton);\n\n                editor.nodes.toolbarButtons[toolName] = toolButton;\n\n            }\n\n        }\n\n        /**\n         * Add inline toolbar tools\n         */\n        editor.ui.addInlineToolbarTools();\n\n\n    };\n\n    ui.addInlineToolbarTools = function () {\n\n        var tools = {\n\n            bold: {\n                icon    : 'ce-icon-bold',\n                command : 'bold'\n            },\n\n            italic: {\n                icon    : 'ce-icon-italic',\n                command : 'italic'\n            },\n\n            underline: {\n                icon    : 'ce-icon-underline',\n                command : 'underline'\n            },\n\n            link: {\n                icon    : 'ce-icon-link',\n                command : 'createLink'\n            }\n        };\n\n        var toolButton,\n            tool;\n\n        for(var name in tools) {\n\n            tool = tools[name];\n\n            toolButton = editor.draw.toolbarButtonInline(name, tool.icon);\n\n            editor.nodes.inlineToolbar.buttons.appendChild(toolButton);\n            /**\n             * Add callbacks to this buttons\n             */\n            editor.ui.setInlineToolbarButtonBehaviour(toolButton, tool.command);\n\n        }\n\n    };\n\n    /**\n     * @private\n     * Bind editor UI events\n     */\n    ui.bindEvents = function () {\n\n        editor.core.log('ui.bindEvents fired', 'info');\n\n        // window.addEventListener('error', function (errorMsg, url, lineNumber) {\n        //     editor.notifications.errorThrown(errorMsg, event);\n        // }, false );\n\n        /** All keydowns on Document */\n        document.addEventListener('keydown', editor.callback.globalKeydown, false );\n\n        /** All keydowns on Redactor zone */\n        editor.nodes.redactor.addEventListener('keydown', editor.callback.redactorKeyDown, false);\n\n        /** All keydowns on Document */\n        document.addEventListener('keyup', editor.callback.globalKeyup, false );\n\n        /**\n         * Mouse click to radactor\n         */\n        editor.nodes.redactor.addEventListener('click', editor.callback.redactorClicked, false );\n\n        /**\n         * Clicks to the Plus button\n         */\n        editor.nodes.plusButton.addEventListener('click', editor.callback.plusButtonClicked, false);\n\n        /**\n         * Clicks to SETTINGS button in toolbar\n         */\n        editor.nodes.showSettingsButton.addEventListener('click', editor.callback.showSettingsButtonClicked, false );\n\n        /**\n         *  @deprecated ( but now in use for syncronization );\n         *  Any redactor changes: keyboard input, mouse cut/paste, drag-n-drop text\n         */\n        // editor.nodes.redactor.addEventListener('input', editor.callback.redactorInputEvent, false );\n\n        /** Bind click listeners on toolbar buttons */\n        for (var button in editor.nodes.toolbarButtons) {\n\n            editor.nodes.toolbarButtons[button].addEventListener('click', editor.callback.toolbarButtonClicked, false);\n\n        }\n\n    };\n\n    /**\n     * Initialize plugins before using\n     * Ex. Load scripts or call some internal methods\n     * @return Promise\n     */\n    ui.preparePlugins = function () {\n\n        return new Promise(function (resolve_, reject_) {\n\n            let pluginName,\n                plugin,\n                queue = [],\n                sequence;\n\n            for ( pluginName in editor.tools ) {\n\n                plugin = editor.tools[pluginName];\n\n                if (plugin.prepare && typeof plugin.prepare != 'function' || !plugin.prepare) {\n\n                    continue;\n\n                }\n\n                queue.push(plugin);\n\n            }\n\n            /** Make a sequence from blocks that have prepare method */\n            sequence = Promise.resolve();\n\n            sequence.then(function () {\n\n                return queue;\n\n            })\n\n            .then(function (request) {\n\n                return new Promise (function (continue_, abort_) {\n\n                    request.reduce(function (previousValue, currentValue, index) {\n\n                        return previousValue.then( function () {\n\n                            return new Promise ( function (ahead_, away_) {\n\n                                callPluginsPrepareMethod_( currentValue )\n\n                                    .then( ahead_ )\n\n                                    .then( function () {\n\n                                        currentValue.available = true;\n\n                                        if (index == request.length - 1) {\n\n                                            continue_();\n\n                                        }\n\n                                    })\n\n                                    .catch(function () {\n\n                                        editor.core.log('Plugin was not loaded', 'warn', currentValue);\n                                        currentValue.available = false;\n\n                                        /** Go ahead even some plugin has problems */\n                                        ahead_();\n\n                                        /** If last plugin has problems then just ignore and continue */\n                                        if (index == request.length - 1) {\n\n                                            continue_();\n\n                                        }\n\n                                    });\n\n                            });\n\n                        });\n\n                    }, Promise.resolve() );\n\n                });\n\n            })\n\n            .then(function () {\n\n                editor.core.log('Basic functionality initialized', 'info');\n                resolve_();\n\n            }).catch(function (error) {\n\n                reject_(error);\n\n            });\n\n        });\n\n    };\n\n    var callPluginsPrepareMethod_ = function (plugin) {\n\n        return plugin.prepare( plugin.config || {} );\n\n    };\n\n    ui.addBlockHandlers = function (block) {\n\n        if (!block) return;\n\n        /**\n         * Block keydowns\n         */\n        block.addEventListener('keydown', editor.callback.blockKeydown, false);\n\n        /**\n         * Pasting content from another source\n         * We have two type of sanitization\n         * First - uses deep-first search algorithm to get sub nodes,\n         * sanitizes whole Block_content and replaces cleared nodes\n         * This method is deprecated\n         * Method is used in editor.callback.blockPaste(event)\n         *\n         * Secont - uses Mutation observer.\n         * Observer \"observe\" DOM changes and send changings to callback.\n         * Callback gets changed node, not whole Block_content.\n         * Inserted or changed node, which we've gotten have been cleared and replaced with diry node\n         *\n         * Method is used in editor.callback.blockPasteViaSanitize(event)\n         *\n         * @uses html-janitor\n         * @example editor.callback.blockPasteViaSanitize(event), the second method.\n         *\n         */\n        block.addEventListener('paste', editor.callback.blockPasteCallback, false);\n\n        block.addEventListener('mouseup', editor.toolbar.inline.show, false);\n\n    };\n\n    /** getting all contenteditable elements */\n    ui.saveInputs = function () {\n\n        var redactor = editor.nodes.redactor;\n\n        /** Save all inputs in global variable state */\n        editor.state.inputs = redactor.querySelectorAll('[contenteditable], input');\n\n    };\n\n    /**\n     * Adds first initial block on empty redactor\n     */\n    ui.addInitialBlock = function () {\n\n        var initialBlockType = editor.settings.initialBlockPlugin,\n            initialBlock;\n\n        if ( !editor.tools[initialBlockType] ) {\n\n            editor.core.log('Plugin %o was not implemented and can\\'t be used as initial block', 'warn', initialBlockType);\n            return;\n\n        }\n\n        initialBlock = editor.tools[initialBlockType].render();\n\n        initialBlock.setAttribute('data-placeholder', '  ...');\n\n        editor.content.insertBlock({\n            type  : initialBlockType,\n            block : initialBlock\n        });\n\n        editor.content.workingNodeChanged(initialBlock);\n\n    };\n\n    ui.setInlineToolbarButtonBehaviour = function (button, type) {\n\n        button.addEventListener('mousedown', function (event) {\n\n            editor.toolbar.inline.toolClicked(event, type);\n\n        }, false);\n\n    };\n\n    return ui;\n\n})({});\n\n\n// WEBPACK FOOTER //\n// ./modules/ui.js","/**\n *\n * Codex.Editor Transport Module\n *\n * @author Codex Team\n * @version 1.0\n */\nlet editor = codex.editor;\n\nmodule.exports = (function (transport) {\n\n    transport.input = null;\n\n    /**\n     * @property {Object} arguments - keep plugin settings and defined callbacks\n     */\n    transport.arguments = null;\n\n    transport.prepare = function () {\n\n        var input = document.createElement('INPUT');\n\n        input.type = 'file';\n        input.addEventListener('change', editor.transport.fileSelected);\n\n        editor.transport.input = input;\n\n    };\n\n    /** Clear input when files is uploaded */\n    transport.clearInput = function () {\n\n        /** Remove old input */\n        this.input = null;\n\n        /** Prepare new one */\n        this.prepare();\n\n    };\n\n    /**\n     * Callback for file selection\n     * @param {Event} event\n     */\n    transport.fileSelected = function () {\n\n        var input       = this,\n            files       = input.files,\n            formdData   = new FormData();\n\n        formdData.append('files', files[0], files[0].name);\n\n        editor.transport.ajax({\n            data : formdData,\n            beforeSend : editor.transport.arguments.beforeSend,\n            success    : editor.transport.arguments.success,\n            error      : editor.transport.arguments.error\n        });\n\n    };\n\n    /**\n     * Use plugin callbacks\n     * @protected\n     */\n    transport.selectAndUpload = function (args) {\n\n        this.arguments = args;\n        this.input.click();\n\n    };\n\n    /**\n     * Ajax requests module\n     * @todo use core.ajax\n     */\n    transport.ajax = function (params) {\n\n        var xhr = new XMLHttpRequest(),\n            beforeSend = typeof params.beforeSend == 'function' ? params.beforeSend : function () {},\n            success    = typeof params.success    == 'function' ? params.success : function () {},\n            error      = typeof params.error      == 'function' ? params.error   : function () {};\n\n        beforeSend();\n\n        xhr.open('POST', editor.settings.uploadImagesUrl, true);\n\n        xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');\n\n        xhr.onload = function () {\n\n            if (xhr.status === 200) {\n\n                success(xhr.responseText);\n\n            } else {\n\n                editor.core.log('request error: %o', xhr);\n                error();\n\n            }\n\n        };\n\n        xhr.send(params.data);\n        this.clearInput();\n\n    };\n\n    return transport;\n\n})({});\n\n\n// WEBPACK FOOTER //\n// ./modules/transport.js","/**\n * Codex Editor Renderer Module\n *\n * @author Codex Team\n * @version 1.0\n */\n\nlet editor = codex.editor;\n\nmodule.exports = (function (renderer) {\n\n    /**\n     * Asyncronously parses input JSON to redactor blocks\n     */\n    renderer.makeBlocksFromData = function () {\n\n        /**\n         * If redactor is empty, add first paragraph to start writing\n         */\n        if (!editor.state.blocks.items.length) {\n\n            editor.ui.addInitialBlock();\n            return;\n\n        }\n\n        Promise.resolve()\n\n        /** First, get JSON from state */\n            .then(function () {\n\n                return editor.state.blocks;\n\n            })\n\n            /** Then, start to iterate they */\n            .then(editor.renderer.appendBlocks)\n\n            /** Write log if something goes wrong */\n            .catch(function (error) {\n\n                editor.core.log('Error while parsing JSON: %o', 'error', error);\n\n            });\n\n    };\n\n    /**\n     * Parses JSON to blocks\n     * @param {object} data\n     * @return Primise -> nodeList\n     */\n    renderer.appendBlocks = function (data) {\n\n        var blocks = data.items;\n\n        /**\n         * Sequence of one-by-one blocks appending\n         * Uses to save blocks order after async-handler\n         */\n        var nodeSequence = Promise.resolve();\n\n        for (var index = 0; index < blocks.length ; index++ ) {\n\n            /** Add node to sequence at specified index */\n            editor.renderer.appendNodeAtIndex(nodeSequence, blocks, index);\n\n        }\n\n    };\n\n    /**\n     * Append node at specified index\n     */\n    renderer.appendNodeAtIndex = function (nodeSequence, blocks, index) {\n\n        /** We need to append node to sequence */\n        nodeSequence\n\n        /** first, get node async-aware */\n            .then(function () {\n\n                return editor.renderer.getNodeAsync(blocks, index);\n\n            })\n\n            /**\n             * second, compose editor-block from JSON object\n             */\n            .then(editor.renderer.createBlockFromData)\n\n            /**\n             * now insert block to redactor\n             */\n            .then(function (blockData) {\n\n                /**\n                 * blockData has 'block', 'type' and 'stretched' information\n                 */\n                editor.content.insertBlock(blockData);\n\n                /** Pass created block to next step */\n                return blockData.block;\n\n            })\n\n            /** Log if something wrong with node */\n            .catch(function (error) {\n\n                editor.core.log('Node skipped while parsing because %o', 'error', error);\n\n            });\n\n    };\n\n    /**\n     * Asynchronously returns block data from blocksList by index\n     * @return Promise to node\n     */\n    renderer.getNodeAsync = function (blocksList, index) {\n\n        return Promise.resolve().then(function () {\n\n            return blocksList[index];\n\n        });\n\n    };\n\n    /**\n     * Creates editor block by JSON-data\n     *\n     * @uses render method of each plugin\n     *\n     * @param {object} blockData looks like\n     *                            { header : {\n     *                                            text: '',\n     *                                            type: 'H3', ...\n     *                                        }\n     *                            }\n     * @return {object} with type and Element\n     */\n    renderer.createBlockFromData = function (blockData) {\n\n        /** New parser */\n        var block,\n            ArrayOfCachedData = codex.editor.state.ArrayOfCachedData,\n            pluginName = blockData.type,\n            cover      = blockData.cover;\n\n        /** Get first key of object that stores plugin name */\n        // for (var pluginName in blockData) break;\n\n        /** Check for plugin existance */\n        if (!editor.tools[pluginName]) {\n\n            throw Error(`Plugin ${pluginName} not found`);\n\n        }\n\n        /** Check for plugin having render method */\n        if (typeof editor.tools[pluginName].render != 'function') {\n\n            throw Error(`Plugin ${pluginName} must have render method`);\n\n        }\n\n        if ( editor.tools[pluginName].available === false ) {\n\n            block = editor.draw.unavailableBlock(ArrayOfCachedData.length);\n\n            /** Save to restore data of unavailable plugins */\n            ArrayOfCachedData.push(blockData.data);\n\n        } else {\n\n            /** New Parser */\n            block = editor.tools[pluginName].render(blockData.data);\n\n        }\n\n        /** is first-level block stretched */\n        var stretched = editor.tools[pluginName].isStretched || false;\n\n        /** Retrun type and block */\n        return {\n            type      : pluginName,\n            block     : block,\n            stretched : stretched,\n            cover     : cover\n        };\n\n    };\n\n    return renderer;\n\n})({});\n\n\n// WEBPACK FOOTER //\n// ./modules/renderer.js","/**\n * Codex Editor Saver\n *\n * @author Codex Team\n * @version 1.0.2\n */\n\nlet editor = codex.editor;\n\nmodule.exports = (function (saver) {\n\n    /**\n     * Saves blocks\n     * @private\n     */\n    saver.saveBlocks = function () {\n\n        /** Save html content of redactor to memory */\n        editor.state.html = editor.nodes.redactor.innerHTML;\n\n        /** Empty jsonOutput state */\n        editor.state.jsonOutput = [];\n\n        Promise.resolve()\n\n            .then(function () {\n\n                return editor.nodes.redactor.childNodes;\n\n            })\n            /** Making a sequence from separate blocks */\n            .then(editor.saver.makeQueue)\n\n            .then(function () {\n                // editor.nodes.textarea.innerHTML = editor.state.html;\n            })\n\n            .catch( function (error) {\n\n                editor.core.log(error);\n\n            });\n\n    };\n\n    saver.makeQueue = function (blocks) {\n\n        var queue = Promise.resolve();\n\n        for(var index = 0; index < blocks.length; index++) {\n\n            /** Add node to sequence at specified index */\n            editor.saver.getBlockData(queue, blocks, index);\n\n        }\n\n    };\n\n    /** Gets every block and makes From Data */\n    saver.getBlockData = function (queue, blocks, index) {\n\n        queue.then(function () {\n\n            return editor.saver.getNodeAsync(blocks, index);\n\n        })\n\n            .then(editor.saver.makeFormDataFromBlocks);\n\n    };\n\n\n    /**\n     * Asynchronously returns block data from blocksList by index\n     * @return Promise to node\n     */\n    saver.getNodeAsync = function (blocksList, index) {\n\n        return Promise.resolve().then(function () {\n\n            return blocksList[index];\n\n        });\n\n    };\n\n    saver.makeFormDataFromBlocks = function (block) {\n\n        var pluginName = block.dataset.tool;\n\n        /** Check for plugin existance */\n        if (!editor.tools[pluginName]) {\n\n            throw Error(`Plugin ${pluginName} not found`);\n\n        }\n\n        /** Check for plugin having render method */\n        if (typeof editor.tools[pluginName].save != 'function') {\n\n            throw Error(`Plugin ${pluginName} must have save method`);\n\n        }\n\n        /** Result saver */\n        var blockContent   = block.childNodes[0],\n            pluginsContent = blockContent.childNodes[0],\n            savedData,\n            ArrayOfCachedData = codex.editor.state.ArrayOfCachedData,\n            cacheId,\n            output;\n\n        /** If plugin wasn't available then return data from cache */\n        if ( editor.tools[pluginName].available === false ) {\n\n            cacheId = pluginsContent.dataset.cacheId;\n            savedData = ArrayOfCachedData[cacheId];\n\n        } else {\n\n            savedData = editor.tools[pluginName].save(pluginsContent);\n\n            if (editor.tools[pluginName].validate) {\n\n                var result = editor.tools[pluginName].validate(savedData);\n\n                /**\n                 * Do not allow invalid data\n                 */\n                if (!result)\n                    return;\n\n            }\n\n        }\n\n        output = {\n            type: pluginName,\n            data: savedData\n        };\n\n        /** Marks Blocks that will be in main page */\n        output.cover = block.classList.contains(editor.ui.className.BLOCK_IN_FEED_MODE);\n\n        editor.state.jsonOutput.push(output);\n\n    };\n\n    return saver;\n\n})({});\n\n\n// WEBPACK FOOTER //\n// ./modules/saver.js","/**\n * Codex Editor Content Module\n * Works with DOM\n *\n * @author Codex Team\n * @version 1.3.11\n */\nlet editor = codex.editor;\n\nmodule.exports = (function (content) {\n\n    /**\n     * Links to current active block\n     * @type {null | Element}\n     */\n    content.currentNode = null;\n\n    /**\n     * clicked in redactor area\n     * @type {null | Boolean}\n     */\n    content.editorAreaHightlighted = null;\n\n    /**\n     * Synchronizes redactor with original textarea\n     */\n    content.sync = function () {\n\n        editor.core.log('syncing...');\n\n        /**\n         * Save redactor content to editor.state\n         */\n        editor.state.html = editor.nodes.redactor.innerHTML;\n\n    };\n\n    /**\n     * @deprecated\n     */\n    content.getNodeFocused = function () {\n\n        var selection = window.getSelection(),\n            focused;\n\n        if (selection.anchorNode === null) {\n\n            return null;\n\n        }\n\n        if ( selection.anchorNode.nodeType == editor.core.nodeTypes.TAG ) {\n\n            focused = selection.anchorNode;\n\n        } else {\n\n            focused = selection.focusNode.parentElement;\n\n        }\n\n        if ( !editor.parser.isFirstLevelBlock(focused) ) {\n\n            /** Iterate with parent nodes to find first-level*/\n            var parent = focused.parentNode;\n\n            while (parent && !editor.parser.isFirstLevelBlock(parent)) {\n\n                parent = parent.parentNode;\n\n            }\n\n            focused = parent;\n\n        }\n\n        if (focused != editor.nodes.redactor) {\n\n            return focused;\n\n        }\n\n        return null;\n\n    };\n\n    /**\n     * Appends background to the block\n     */\n    content.markBlock = function () {\n\n        editor.content.currentNode.classList.add(editor.ui.className.BLOCK_HIGHLIGHTED);\n\n    };\n\n    /**\n     * Clear background\n     */\n    content.clearMark = function () {\n\n        if (editor.content.currentNode) {\n\n            editor.content.currentNode.classList.remove(editor.ui.className.BLOCK_HIGHLIGHTED);\n\n        }\n\n    };\n\n    /**\n     * @private\n     *\n     * Finds first-level block\n     * @param {Element} node - selected or clicked in redactors area node\n     */\n    content.getFirstLevelBlock = function (node) {\n\n        if (!editor.core.isDomNode(node)) {\n\n            node = node.parentNode;\n\n        }\n\n        if (node === editor.nodes.redactor || node === document.body) {\n\n            return null;\n\n        } else {\n\n            while(!node.classList.contains(editor.ui.className.BLOCK_CLASSNAME)) {\n\n                node = node.parentNode;\n\n            }\n\n            return node;\n\n        }\n\n    };\n\n    /**\n     * Trigger this event when working node changed\n     * @param {Element} targetNode - first-level of this node will be current\n     * If targetNode is first-level then we set it as current else we look for parents to find first-level\n     */\n    content.workingNodeChanged = function (targetNode) {\n\n        /** Clear background from previous marked block before we change */\n        editor.content.clearMark();\n\n        if (!targetNode) {\n\n            return;\n\n        }\n\n        this.currentNode = this.getFirstLevelBlock(targetNode);\n\n    };\n\n    /**\n     * Replaces one redactor block with another\n     * @protected\n     * @param {Element} targetBlock - block to replace. Mostly currentNode.\n     * @param {Element} newBlock\n     * @param {string} newBlockType - type of new block; we need to store it to data-attribute\n     *\n     * [!] Function does not saves old block content.\n     *     You can get it manually and pass with newBlock.innerHTML\n     */\n    content.replaceBlock = function (targetBlock, newBlock) {\n\n        if (!targetBlock || !newBlock) {\n\n            editor.core.log('replaceBlock: missed params');\n            return;\n\n        }\n\n        /** If target-block is not a frist-level block, then we iterate parents to find it */\n        while(!targetBlock.classList.contains(editor.ui.className.BLOCK_CLASSNAME)) {\n\n            targetBlock = targetBlock.parentNode;\n\n        }\n\n        /**\n         * Check is this block was in feed\n         * If true, than set switched block also covered\n         */\n        if (targetBlock.classList.contains(editor.ui.className.BLOCK_IN_FEED_MODE)) {\n\n            newBlock.classList.add(editor.ui.className.BLOCK_IN_FEED_MODE);\n\n        }\n\n        /** Replacing */\n        editor.nodes.redactor.replaceChild(newBlock, targetBlock);\n\n        /**\n         * Set new node as current\n         */\n        editor.content.workingNodeChanged(newBlock);\n\n        /**\n         * Add block handlers\n         */\n        editor.ui.addBlockHandlers(newBlock);\n\n        /**\n         * Save changes\n         */\n        editor.ui.saveInputs();\n\n    };\n\n    /**\n     * @private\n     *\n     * Inserts new block to redactor\n     * Wrapps block into a DIV with BLOCK_CLASSNAME class\n     *\n     * @param blockData          {object}\n     * @param blockData.block    {Element}   element with block content\n     * @param blockData.type     {string}    block plugin\n     * @param needPlaceCaret     {bool}      pass true to set caret in new block\n     *\n     */\n    content.insertBlock = function ( blockData, needPlaceCaret ) {\n\n        var workingBlock    = editor.content.currentNode,\n            newBlockContent = blockData.block,\n            blockType       = blockData.type,\n            cover           = blockData.cover,\n            isStretched     = blockData.stretched;\n\n        var newBlock = editor.content.composeNewBlock(newBlockContent, blockType, isStretched);\n\n        if (cover === true) {\n\n            newBlock.classList.add(editor.ui.className.BLOCK_IN_FEED_MODE);\n\n        }\n\n        if (workingBlock) {\n\n            editor.core.insertAfter(workingBlock, newBlock);\n\n        } else {\n\n            /**\n             * If redactor is empty, append as first child\n             */\n            editor.nodes.redactor.appendChild(newBlock);\n\n        }\n\n        /**\n         * Block handler\n         */\n        editor.ui.addBlockHandlers(newBlock);\n\n        /**\n         * Set new node as current\n         */\n        editor.content.workingNodeChanged(newBlock);\n\n        /**\n         * Save changes\n         */\n        editor.ui.saveInputs();\n\n\n        if ( needPlaceCaret ) {\n\n            /**\n             * If we don't know input index then we set default value -1\n             */\n            var currentInputIndex = editor.caret.getCurrentInputIndex() || -1;\n\n\n            if (currentInputIndex == -1) {\n\n\n                var editableElement = newBlock.querySelector('[contenteditable]'),\n                    emptyText       = document.createTextNode('');\n\n                editableElement.appendChild(emptyText);\n                editor.caret.set(editableElement, 0, 0);\n\n                editor.toolbar.move();\n                editor.toolbar.showPlusButton();\n\n\n            } else {\n\n                if (currentInputIndex === editor.state.inputs.length - 1)\n                    return;\n\n                /** Timeout for browsers execution */\n                window.setTimeout(function () {\n\n                    /** Setting to the new input */\n                    editor.caret.setToNextBlock(currentInputIndex);\n                    editor.toolbar.move();\n                    editor.toolbar.open();\n\n                }, 10);\n\n            }\n\n        }\n\n        /**\n         * Block is inserted, wait for new click that defined focusing on editors area\n         * @type {boolean}\n         */\n        content.editorAreaHightlighted = false;\n\n    };\n\n    /**\n     * Replaces blocks with saving content\n     * @protected\n     * @param {Element} noteToReplace\n     * @param {Element} newNode\n     * @param {Element} blockType\n     */\n    content.switchBlock = function (blockToReplace, newBlock, tool) {\n\n        var newBlockComposed = editor.content.composeNewBlock(newBlock, tool);\n\n        /** Replacing */\n        editor.content.replaceBlock(blockToReplace, newBlockComposed);\n\n        /** Save new Inputs when block is changed */\n        editor.ui.saveInputs();\n\n    };\n\n    /**\n     * Iterates between child noted and looking for #text node on deepest level\n     * @private\n     * @param {Element} block - node where find\n     * @param {int} postiton - starting postion\n     *      Example: childNodex.length to find from the end\n     *               or 0 to find from the start\n     * @return {Text} block\n     * @uses DFS\n     */\n    content.getDeepestTextNodeFromPosition = function (block, position) {\n\n        /**\n         * Clear Block from empty and useless spaces with trim.\n         * Such nodes we should remove\n         */\n        var blockChilds = block.childNodes,\n            index,\n            node,\n            text;\n\n        for(index = 0; index < blockChilds.length; index++) {\n\n            node = blockChilds[index];\n\n            if (node.nodeType == editor.core.nodeTypes.TEXT) {\n\n                text = node.textContent.trim();\n\n                /** Text is empty. We should remove this child from node before we start DFS\n                 * decrease the quantity of childs.\n                 */\n                if (text === '') {\n\n                    block.removeChild(node);\n                    position--;\n\n                }\n\n            }\n\n        }\n\n        if (block.childNodes.length === 0) {\n\n            return document.createTextNode('');\n\n        }\n\n        /** Setting default position when we deleted all empty nodes */\n        if ( position < 0 )\n            position = 1;\n\n        var lookingFromStart = false;\n\n        /** For looking from START */\n        if (position === 0) {\n\n            lookingFromStart = true;\n            position = 1;\n\n        }\n\n        while ( position ) {\n\n            /** initial verticle of node. */\n            if ( lookingFromStart ) {\n\n                block = block.childNodes[0];\n\n            } else {\n\n                block = block.childNodes[position - 1];\n\n            }\n\n            if ( block.nodeType == editor.core.nodeTypes.TAG ) {\n\n                position = block.childNodes.length;\n\n            } else if (block.nodeType == editor.core.nodeTypes.TEXT ) {\n\n                position = 0;\n\n            }\n\n        }\n\n        return block;\n\n    };\n\n    /**\n     * @private\n     */\n    content.composeNewBlock = function (block, tool, isStretched) {\n\n        var newBlock     = editor.draw.node('DIV', editor.ui.className.BLOCK_CLASSNAME, {}),\n            blockContent = editor.draw.node('DIV', editor.ui.className.BLOCK_CONTENT, {});\n\n        blockContent.appendChild(block);\n        newBlock.appendChild(blockContent);\n\n        if (isStretched) {\n\n            blockContent.classList.add(editor.ui.className.BLOCK_STRETCHED);\n\n        }\n\n        newBlock.dataset.tool = tool;\n        return newBlock;\n\n    };\n\n    /**\n     * Returns Range object of current selection\n     */\n    content.getRange = function () {\n\n        var selection = window.getSelection().getRangeAt(0);\n\n        return selection;\n\n    };\n\n    /**\n     * Divides block in two blocks (after and before caret)\n     * @private\n     * @param {Int} inputIndex - target input index\n     */\n    content.splitBlock = function (inputIndex) {\n\n        var selection      = window.getSelection(),\n            anchorNode     = selection.anchorNode,\n            anchorNodeText = anchorNode.textContent,\n            caretOffset    = selection.anchorOffset,\n            textBeforeCaret,\n            textNodeBeforeCaret,\n            textAfterCaret,\n            textNodeAfterCaret;\n\n        var currentBlock = editor.content.currentNode.querySelector('[contentEditable]');\n\n\n        textBeforeCaret     = anchorNodeText.substring(0, caretOffset);\n        textAfterCaret      = anchorNodeText.substring(caretOffset);\n\n        textNodeBeforeCaret = document.createTextNode(textBeforeCaret);\n\n        if (textAfterCaret) {\n\n            textNodeAfterCaret  = document.createTextNode(textAfterCaret);\n\n        }\n\n        var previousChilds = [],\n            nextChilds     = [],\n            reachedCurrent = false;\n\n        if (textNodeAfterCaret) {\n\n            nextChilds.push(textNodeAfterCaret);\n\n        }\n\n        for ( var i = 0, child; !!(child = currentBlock.childNodes[i]); i++) {\n\n            if ( child != anchorNode ) {\n\n                if ( !reachedCurrent ) {\n\n                    previousChilds.push(child);\n\n                } else {\n\n                    nextChilds.push(child);\n\n                }\n\n            } else {\n\n                reachedCurrent = true;\n\n            }\n\n        }\n\n        /** Clear current input */\n        editor.state.inputs[inputIndex].innerHTML = '';\n\n        /**\n         * Append all childs founded before anchorNode\n         */\n        var previousChildsLength = previousChilds.length;\n\n        for(i = 0; i < previousChildsLength; i++) {\n\n            editor.state.inputs[inputIndex].appendChild(previousChilds[i]);\n\n        }\n\n        editor.state.inputs[inputIndex].appendChild(textNodeBeforeCaret);\n\n        /**\n         * Append text node which is after caret\n         */\n        var nextChildsLength = nextChilds.length,\n            newNode          = document.createElement('div');\n\n        for(i = 0; i < nextChildsLength; i++) {\n\n            newNode.appendChild(nextChilds[i]);\n\n        }\n\n        newNode = newNode.innerHTML;\n\n        /** This type of block creates when enter is pressed */\n        var NEW_BLOCK_TYPE = editor.settings.initialBlockPlugin;\n\n        /**\n         * Make new paragraph with text after caret\n         */\n        editor.content.insertBlock({\n            type  : NEW_BLOCK_TYPE,\n            block : editor.tools[NEW_BLOCK_TYPE].render({\n                text : newNode\n            })\n        }, true );\n\n    };\n\n    /**\n     * Merges two blocks  current and target\n     * If target index is not exist, then previous will be as target\n     */\n    content.mergeBlocks = function (currentInputIndex, targetInputIndex) {\n\n        /** If current input index is zero, then prevent method execution */\n        if (currentInputIndex === 0) {\n\n            return;\n\n        }\n\n        var targetInput,\n            currentInputContent = editor.state.inputs[currentInputIndex].innerHTML;\n\n        if (!targetInputIndex) {\n\n            targetInput = editor.state.inputs[currentInputIndex - 1];\n\n        } else {\n\n            targetInput = editor.state.inputs[targetInputIndex];\n\n        }\n\n        targetInput.innerHTML += currentInputContent;\n\n    };\n\n    /**\n     * @private\n     *\n     * Callback for HTML Mutations\n     * @param {Array} mutation - Mutation Record\n     */\n    content.paste = function (mutation) {\n\n        var workingNode = editor.content.currentNode,\n            tool        = workingNode.dataset.tool;\n\n        if (editor.tools[tool].allowedToPaste) {\n\n            editor.content.sanitize.call(this, mutation.target);\n\n        } else {\n\n            editor.content.pasteTextContent(mutation.addedNodes);\n\n        }\n\n    };\n\n    /**\n     * @private\n     *\n     * gets only text/plain content of node\n     * @param {Element} target - HTML node\n     */\n    content.pasteTextContent = function (nodes) {\n\n        var node = nodes[0],\n            textNode;\n\n        if (!node) {\n\n            return;\n\n        }\n\n        if (node.nodeType == editor.core.nodeTypes.TEXT) {\n\n            textNode = document.createTextNode(node);\n\n        } else {\n\n            textNode = document.createTextNode(node.textContent);\n\n        }\n\n        if (editor.core.isDomNode(node)) {\n\n            node.parentNode.replaceChild(textNode, node);\n\n        }\n\n    };\n\n    /**\n     * @private\n     *\n     * Sanitizes HTML content\n     * @param {Element} target - inserted element\n     * @uses Sanitize library html-janitor\n     */\n    content.sanitize = function (target) {\n\n        if (!target) {\n\n            return;\n\n        }\n\n        var node = target[0];\n\n        if (!node) {\n\n            return;\n\n        }\n\n        /**\n         * Disconnect Observer\n         * hierarchy of function calls inherits context of observer\n         */\n        this.disconnect();\n\n        /**\n         * Don't sanitize text node\n         */\n        if (node.nodeType == editor.core.nodeTypes.TEXT) {\n\n            return;\n\n        }\n\n        /**\n         * Clear dirty content\n         */\n        var cleaner = editor.sanitizer.init(editor.satinizer.Config.BASIC),\n            clean = cleaner.clean(target.outerHTML);\n\n        var div = editor.draw.node('DIV', [], { innerHTML: clean });\n\n        node.replaceWith(div.childNodes[0]);\n\n\n    };\n\n    /**\n     * Iterates all right siblings and parents, which has right siblings\n     * while it does not reached the first-level block\n     *\n     * @param {Element} node\n     * @return {boolean}\n     */\n    content.isLastNode = function (node) {\n\n        // console.log('  ');\n\n        var allChecked = false;\n\n        while ( !allChecked ) {\n\n            // console.log('  %o', node);\n            // console.log(',    ');\n\n            if ( !allSiblingsEmpty_(node) ) {\n\n                // console.log('  .   . .');\n                return false;\n\n            }\n\n            node = node.parentNode;\n\n            /**\n             *     ,      \n             */\n            if ( node.classList.contains(editor.ui.className.BLOCK_CONTENT) ) {\n\n                allChecked = true;\n\n            }\n\n        }\n\n        return true;\n\n    };\n\n    /**\n     * Checks if all element right siblings is empty\n     * @param node\n     */\n    var allSiblingsEmpty_ = function (node) {\n\n        /**\n         *  ,      \n         */\n        var sibling = node.nextSibling;\n\n        while ( sibling ) {\n\n            if (sibling.textContent.length) {\n\n                return false;\n\n            }\n\n            sibling = sibling.nextSibling;\n\n        }\n\n        return true;\n\n    };\n\n    /**\n     * @public\n     *\n     * @param [String] htmlString - html content as string\n     * @return {string} - html content as string\n     */\n    content.wrapTextWithParagraphs = function (htmlString) {\n\n        var wrapper = document.createElement('DIV'),\n            newWrapper = document.createElement('DIV'),\n            i,\n            paragraph,\n            firstLevelBlocks = ['DIV', 'P'],\n            blockTyped,\n            node;\n\n        /**\n         * Make HTML Element to Wrap Text\n         * It allows us to work with input data as HTML content\n         */\n        wrapper.innerHTML = htmlString;\n        paragraph = document.createElement('P');\n\n        for (i = 0; i < wrapper.childNodes.length; i++) {\n\n            node = wrapper.childNodes[i];\n\n            blockTyped = firstLevelBlocks.indexOf(node.tagName) != -1;\n\n            /**\n             * If node is first-levet\n             * we add this node to our new wrapper\n             */\n            if ( blockTyped ) {\n\n                /**\n                 * If we had splitted inline nodes to paragraph before\n                 */\n                if ( paragraph.childNodes.length ) {\n\n                    newWrapper.appendChild(paragraph.cloneNode(true));\n\n                    /** empty paragraph */\n                    paragraph = null;\n                    paragraph = document.createElement('P');\n\n                }\n\n                newWrapper.appendChild(node.cloneNode(true));\n\n            } else {\n\n                /** Collect all inline nodes to one as paragraph */\n                paragraph.appendChild(node.cloneNode(true));\n\n                /** if node is last we should append this node to paragraph and paragraph to new wrapper */\n                if ( i == wrapper.childNodes.length - 1 ) {\n\n                    newWrapper.appendChild(paragraph.cloneNode(true));\n\n                }\n\n            }\n\n        }\n\n        return newWrapper.innerHTML;\n\n    };\n\n    return content;\n\n})({});\n\n\n// WEBPACK FOOTER //\n// ./modules/content.js","/**\n * Codex Editor toolbar module\n *\n * Contains:\n *  - Inline toolbox\n *  - Toolbox within plus button\n *  - Settings section\n *\n * @author Codex Team\n * @version 1.0\n */\n\nlet editor = codex.editor;\n\nmodule.exports = (function (toolbar) {\n\n    toolbar.settings = require('./settings');\n    toolbar.inline   = require('./inline');\n    toolbar.toolbox  = require('./toolbox');\n\n    /**\n     * Margin between focused node and toolbar\n     */\n    toolbar.defaultToolbarHeight = 49;\n\n    toolbar.defaultOffset = 34;\n\n    toolbar.opened = false;\n\n    toolbar.current = null;\n\n    /**\n     * @protected\n     */\n    toolbar.open = function () {\n\n        editor.nodes.toolbar.classList.add('opened');\n        this.opened = true;\n\n    };\n\n    /**\n     * @protected\n     */\n    toolbar.close = function () {\n\n        editor.nodes.toolbar.classList.remove('opened');\n\n        toolbar.opened  = false;\n        toolbar.current = null;\n\n        for (var button in editor.nodes.toolbarButtons) {\n\n            editor.nodes.toolbarButtons[button].classList.remove('selected');\n\n        }\n\n        /** Close toolbox when toolbar is not displayed */\n        editor.toolbar.toolbox.close();\n        editor.toolbar.settings.close();\n\n    };\n\n    toolbar.toggle = function () {\n\n        if ( !this.opened ) {\n\n            this.open();\n\n        } else {\n\n            this.close();\n\n        }\n\n    };\n\n    toolbar.hidePlusButton = function () {\n\n        editor.nodes.plusButton.classList.add('hide');\n\n    };\n\n    toolbar.showPlusButton = function () {\n\n        editor.nodes.plusButton.classList.remove('hide');\n\n    };\n\n    /**\n     * Moving toolbar to the specified node\n     */\n    toolbar.move = function () {\n\n        /** Close Toolbox when we move toolbar */\n        editor.toolbar.toolbox.close();\n\n        if (!editor.content.currentNode) {\n\n            return;\n\n        }\n\n        var newYCoordinate = editor.content.currentNode.offsetTop - (editor.toolbar.defaultToolbarHeight / 2) + editor.toolbar.defaultOffset;\n\n        editor.nodes.toolbar.style.transform = `translate3D(0, ${Math.floor(newYCoordinate)}px, 0)`;\n\n        /** Close trash actions */\n        editor.toolbar.settings.hideRemoveActions();\n\n    };\n\n    return toolbar;\n\n})({});\n\n\n// WEBPACK FOOTER //\n// ./modules/toolbar/toolbar.js","/**\n * Toolbar settings\n *\n * @version 1.0.4\n */\n\nlet editor = codex.editor;\n\nmodule.exports = (function (settings) {\n\n    settings.opened = false;\n\n    settings.setting = null;\n    settings.actions = null;\n\n    settings.cover = null;\n\n    /**\n     * Append and open settings\n     */\n    settings.open = function (toolType) {\n\n        /**\n         * Append settings content\n         * It's stored in tool.settings\n         */\n        if (!editor.tools[toolType] || !editor.tools[toolType].makeSettings ) {\n\n            editor.core.log(`Plugin ${toolType} has no settings`, 'warn');\n            // editor.nodes.pluginSettings.innerHTML = ` ${toolType}   `;\n\n        } else {\n\n            /**\n             * Draw settings block\n             */\n            var settingsBlock = editor.tools[toolType].makeSettings();\n\n            editor.nodes.pluginSettings.appendChild(settingsBlock);\n\n        }\n\n        /** Open settings block */\n        editor.nodes.blockSettings.classList.add('opened');\n        editor.toolbar.settings.addDefaultSettings();\n        this.opened = true;\n\n    };\n\n    /**\n     * Close and clear settings\n     */\n    settings.close = function () {\n\n        editor.nodes.blockSettings.classList.remove('opened');\n        editor.nodes.pluginSettings.innerHTML = '';\n\n        this.opened = false;\n\n    };\n\n    /**\n     * @param {string} toolType - plugin type\n     */\n    settings.toggle = function ( toolType ) {\n\n        if ( !this.opened ) {\n\n            this.open(toolType);\n\n        } else {\n\n            this.close();\n\n        }\n\n    };\n\n    /**\n     * This function adds default core settings\n     */\n    settings.addDefaultSettings = function () {\n\n        /** list of default settings */\n        var feedModeToggler;\n\n        /** Clear block and append initialized settings */\n        editor.nodes.defaultSettings.innerHTML = '';\n\n\n        /** Init all default setting buttons */\n        feedModeToggler = editor.toolbar.settings.makeFeedModeToggler();\n\n        /**\n         * Fill defaultSettings\n         */\n\n        /**\n         * Button that enables/disables Feed-mode\n         * Feed-mode means that block will be showed in articles-feed like cover\n         */\n        editor.nodes.defaultSettings.appendChild(feedModeToggler);\n\n    };\n\n    /**\n     * Cover setting.\n     * This tune highlights block, so that it may be used for showing target block on main page\n     * Draw different setting when block is marked for main page\n     * If TRUE, then we show button that removes this selection\n     * Also defined setting \"Click\" events will be listened and have separate callbacks\n     *\n     * @return {Element} node/button that we place in default settings block\n     */\n    settings.makeFeedModeToggler = function () {\n\n        var isFeedModeActivated = editor.toolbar.settings.isFeedModeActivated(),\n            setting,\n            data;\n\n        if (!isFeedModeActivated) {\n\n            data = {\n                innerHTML : '<i class=\"ce-icon-newspaper\"></i>  '\n            };\n\n        } else {\n\n            data = {\n                innerHTML : '<i class=\"ce-icon-newspaper\"></i>   '\n            };\n\n        }\n\n        setting = editor.draw.node('DIV', editor.ui.className.SETTINGS_ITEM, data);\n        setting.addEventListener('click', editor.toolbar.settings.updateFeedMode, false);\n\n        return setting;\n\n    };\n\n    /**\n     * Updates Feed-mode\n     */\n    settings.updateFeedMode = function () {\n\n        var currentNode = editor.content.currentNode;\n\n        currentNode.classList.toggle(editor.ui.className.BLOCK_IN_FEED_MODE);\n\n        editor.toolbar.settings.close();\n\n    };\n\n    settings.isFeedModeActivated = function () {\n\n        var currentBlock = editor.content.currentNode;\n\n        if (currentBlock) {\n\n            return currentBlock.classList.contains(editor.ui.className.BLOCK_IN_FEED_MODE);\n\n        } else {\n\n            return false;\n\n        }\n\n    };\n\n    /**\n     * Here we will draw buttons and add listeners to components\n     */\n    settings.makeRemoveBlockButton = function () {\n\n        var removeBlockWrapper  = editor.draw.node('SPAN', 'ce-toolbar__remove-btn', {}),\n            settingButton = editor.draw.node('SPAN', 'ce-toolbar__remove-setting', { innerHTML : '<i class=\"ce-icon-trash\"></i>' }),\n            actionWrapper = editor.draw.node('DIV', 'ce-toolbar__remove-confirmation', {}),\n            confirmAction = editor.draw.node('DIV', 'ce-toolbar__remove-confirm', { textContent : ' ' }),\n            cancelAction  = editor.draw.node('DIV', 'ce-toolbar__remove-cancel', { textContent : '' });\n\n        settingButton.addEventListener('click', editor.toolbar.settings.removeButtonClicked, false);\n\n        confirmAction.addEventListener('click', editor.toolbar.settings.confirmRemovingRequest, false);\n\n        cancelAction.addEventListener('click', editor.toolbar.settings.cancelRemovingRequest, false);\n\n        actionWrapper.appendChild(confirmAction);\n        actionWrapper.appendChild(cancelAction);\n\n        removeBlockWrapper.appendChild(settingButton);\n        removeBlockWrapper.appendChild(actionWrapper);\n\n        /** Save setting */\n        editor.toolbar.settings.setting = settingButton;\n        editor.toolbar.settings.actions = actionWrapper;\n\n        return removeBlockWrapper;\n\n    };\n\n    settings.removeButtonClicked = function () {\n\n        var action = editor.toolbar.settings.actions;\n\n        if (action.classList.contains('opened')) {\n\n            editor.toolbar.settings.hideRemoveActions();\n\n        } else {\n\n            editor.toolbar.settings.showRemoveActions();\n\n        }\n\n        editor.toolbar.toolbox.close();\n        editor.toolbar.settings.close();\n\n    };\n\n    settings.cancelRemovingRequest = function () {\n\n        editor.toolbar.settings.actions.classList.remove('opened');\n\n    };\n\n    settings.confirmRemovingRequest = function () {\n\n        var currentBlock = editor.content.currentNode,\n            firstLevelBlocksCount;\n\n        currentBlock.remove();\n\n        firstLevelBlocksCount = editor.nodes.redactor.childNodes.length;\n\n        /**\n         * If all blocks are removed\n         */\n        if (firstLevelBlocksCount === 0) {\n\n            /** update currentNode variable */\n            editor.content.currentNode = null;\n\n            /** Inserting new empty initial block */\n            editor.ui.addInitialBlock();\n\n        }\n\n        editor.ui.saveInputs();\n\n        editor.toolbar.close();\n\n    };\n\n    settings.showRemoveActions = function () {\n\n        editor.toolbar.settings.actions.classList.add('opened');\n\n    };\n\n    settings.hideRemoveActions = function () {\n\n        editor.toolbar.settings.actions.classList.remove('opened');\n\n    };\n\n    return settings;\n\n})({});\n\n\n// WEBPACK FOOTER //\n// ./modules/toolbar/settings.js","/**\n * Inline toolbar\n *\n * Contains from tools:\n * Bold, Italic, Underline and Anchor\n *\n * @author Codex Team\n * @version 1.0\n */\n\nlet editor = codex.editor;\n\nmodule.exports = (function (inline) {\n\n    inline.buttonsOpened = null;\n    inline.actionsOpened = null;\n    inline.wrappersOffset = null;\n\n    /**\n     * saving selection that need for execCommand for styling\n     *\n     */\n    inline.storedSelection = null;\n\n    /**\n     * @protected\n     *\n     * Open inline toobar\n     */\n    inline.show = function () {\n\n        var currentNode = editor.content.currentNode,\n            tool = currentNode.dataset.tool,\n            plugin;\n\n        /**\n         * tool allowed to open inline toolbar\n         */\n        plugin = editor.tools[tool];\n\n        if (!plugin.showInlineToolbar)\n            return;\n\n        var selectedText = inline.getSelectionText(),\n            toolbar      = editor.nodes.inlineToolbar.wrapper;\n\n        if (selectedText.length > 0) {\n\n            /** Move toolbar and open */\n            editor.toolbar.inline.move();\n\n            /** Open inline toolbar */\n            toolbar.classList.add('opened');\n\n            /** show buttons of inline toolbar */\n            editor.toolbar.inline.showButtons();\n\n        }\n\n    };\n\n    /**\n     * @protected\n     *\n     * Closes inline toolbar\n     */\n    inline.close = function () {\n\n        var toolbar = editor.nodes.inlineToolbar.wrapper;\n\n        toolbar.classList.remove('opened');\n\n    };\n\n    /**\n     * @private\n     *\n     * Moving toolbar\n     */\n    inline.move = function () {\n\n        if (!this.wrappersOffset) {\n\n            this.wrappersOffset = this.getWrappersOffset();\n\n        }\n\n        var coords          = this.getSelectionCoords(),\n            defaultOffset   = 0,\n            toolbar         = editor.nodes.inlineToolbar.wrapper,\n            newCoordinateX,\n            newCoordinateY;\n\n        if (toolbar.offsetHeight === 0) {\n\n            defaultOffset = 40;\n\n        }\n\n        newCoordinateX = coords.x - this.wrappersOffset.left;\n        newCoordinateY = coords.y + window.scrollY - this.wrappersOffset.top - defaultOffset - toolbar.offsetHeight;\n\n        toolbar.style.transform = `translate3D(${Math.floor(newCoordinateX)}px, ${Math.floor(newCoordinateY)}px, 0)`;\n\n        /** Close everything */\n        editor.toolbar.inline.closeButtons();\n        editor.toolbar.inline.closeAction();\n\n    };\n\n    /**\n     * @private\n     *\n     * Tool Clicked\n     */\n\n    inline.toolClicked = function (event, type) {\n\n        /**\n         * For simple tools we use default browser function\n         * For more complicated tools, we should write our own behavior\n         */\n        switch (type) {\n            case 'createLink' : editor.toolbar.inline.createLinkAction(event, type); break;\n            default           : editor.toolbar.inline.defaultToolAction(type); break;\n        }\n\n        /**\n         * highlight buttons\n         * after making some action\n         */\n        editor.nodes.inlineToolbar.buttons.childNodes.forEach(editor.toolbar.inline.hightlight);\n\n    };\n\n    /**\n     * @private\n     *\n     * Saving wrappers offset in DOM\n     */\n    inline.getWrappersOffset = function () {\n\n        var wrapper = editor.nodes.wrapper,\n            offset  = this.getOffset(wrapper);\n\n        this.wrappersOffset = offset;\n        return offset;\n\n    };\n\n    /**\n     * @private\n     *\n     * Calculates offset of DOM element\n     *\n     * @param el\n     * @returns {{top: number, left: number}}\n     */\n    inline.getOffset = function ( el ) {\n\n        var _x = 0;\n        var _y = 0;\n\n        while( el && !isNaN( el.offsetLeft ) && !isNaN( el.offsetTop ) ) {\n\n            _x += (el.offsetLeft + el.clientLeft);\n            _y += (el.offsetTop + el.clientTop);\n            el = el.offsetParent;\n\n        }\n        return { top: _y, left: _x };\n\n    };\n\n    /**\n     * @private\n     *\n     * Calculates position of selected text\n     * @returns {{x: number, y: number}}\n     */\n    inline.getSelectionCoords = function () {\n\n        var sel = document.selection, range;\n        var x = 0, y = 0;\n\n        if (sel) {\n\n            if (sel.type != 'Control') {\n\n                range = sel.createRange();\n                range.collapse(true);\n                x = range.boundingLeft;\n                y = range.boundingTop;\n\n            }\n\n        } else if (window.getSelection) {\n\n            sel = window.getSelection();\n\n            if (sel.rangeCount) {\n\n                range = sel.getRangeAt(0).cloneRange();\n                if (range.getClientRects) {\n\n                    range.collapse(true);\n                    var rect = range.getClientRects()[0];\n\n                    if (!rect) {\n\n                        return;\n\n                    }\n\n                    x = rect.left;\n                    y = rect.top;\n\n                }\n\n            }\n\n        }\n        return { x: x, y: y };\n\n    };\n\n    /**\n     * @private\n     *\n     * Returns selected text as String\n     * @returns {string}\n     */\n    inline.getSelectionText = function () {\n\n        var selectedText = '';\n\n        // all modern browsers and IE9+\n        if (window.getSelection) {\n\n            selectedText = window.getSelection().toString();\n\n        }\n\n        return selectedText;\n\n    };\n\n    /** Opens buttons block */\n    inline.showButtons = function () {\n\n        var buttons = editor.nodes.inlineToolbar.buttons;\n\n        buttons.classList.add('opened');\n\n        editor.toolbar.inline.buttonsOpened = true;\n\n        /** highlight buttons */\n        editor.nodes.inlineToolbar.buttons.childNodes.forEach(editor.toolbar.inline.hightlight);\n\n    };\n\n    /** Makes buttons disappear */\n    inline.closeButtons = function () {\n\n        var buttons = editor.nodes.inlineToolbar.buttons;\n\n        buttons.classList.remove('opened');\n\n        editor.toolbar.inline.buttonsOpened = false;\n\n    };\n\n    /** Open buttons defined action if exist */\n    inline.showActions = function () {\n\n        var action = editor.nodes.inlineToolbar.actions;\n\n        action.classList.add('opened');\n\n        editor.toolbar.inline.actionsOpened = true;\n\n    };\n\n    /** Close actions block */\n    inline.closeAction = function () {\n\n        var action = editor.nodes.inlineToolbar.actions;\n\n        action.innerHTML = '';\n        action.classList.remove('opened');\n        editor.toolbar.inline.actionsOpened = false;\n\n    };\n\n\n    /**\n    * Callback for keydowns in inline toolbar \"Insert link...\" input\n    */\n    let inlineToolbarAnchorInputKeydown_ = function (event) {\n\n        if (event.keyCode != editor.core.keys.ENTER) {\n\n            return;\n\n        }\n\n        let editable        = editor.content.currentNode,\n            storedSelection = editor.toolbar.inline.storedSelection;\n\n        editor.toolbar.inline.restoreSelection(editable, storedSelection);\n        editor.toolbar.inline.setAnchor(this.value);\n\n        /**\n         * Preventing events that will be able to happen\n         */\n        event.preventDefault();\n        event.stopImmediatePropagation();\n\n        editor.toolbar.inline.clearRange();\n\n    };\n\n    /** Action for link creation or for setting anchor */\n    inline.createLinkAction = function (event) {\n\n        var isActive = this.isLinkActive();\n\n        var editable        = editor.content.currentNode,\n            storedSelection = editor.toolbar.inline.saveSelection(editable);\n\n        /** Save globally selection */\n        editor.toolbar.inline.storedSelection = storedSelection;\n\n        if (isActive) {\n\n\n            /**\n             * Changing stored selection. if we want to remove anchor from word\n             * we should remove anchor from whole word, not only selected part.\n             * The solution is than we get the length of current link\n             * Change start position to - end of selection minus length of anchor\n             */\n            editor.toolbar.inline.restoreSelection(editable, storedSelection);\n\n            editor.toolbar.inline.defaultToolAction('unlink');\n\n        } else {\n\n            /** Create input and close buttons */\n            var action = editor.draw.inputForLink();\n\n            editor.nodes.inlineToolbar.actions.appendChild(action);\n\n            editor.toolbar.inline.closeButtons();\n            editor.toolbar.inline.showActions();\n\n            /**\n             * focus to input\n             * Solution: https://developer.mozilla.org/ru/docs/Web/API/HTMLElement/focus\n             * Prevents event after showing input and when we need to focus an input which is in unexisted form\n             */\n            action.focus();\n            event.preventDefault();\n\n            /** Callback to link action */\n            action.addEventListener('keydown', inlineToolbarAnchorInputKeydown_, false);\n\n        }\n\n    };\n\n    inline.isLinkActive = function () {\n\n        var isActive = false;\n\n        editor.nodes.inlineToolbar.buttons.childNodes.forEach(function (tool) {\n\n            var dataType = tool.dataset.type;\n\n            if (dataType == 'link' && tool.classList.contains('hightlighted')) {\n\n                isActive = true;\n\n            }\n\n        });\n\n        return isActive;\n\n    };\n\n    /** default action behavior of tool */\n    inline.defaultToolAction = function (type) {\n\n        document.execCommand(type, false, null);\n\n    };\n\n    /**\n     * @private\n     *\n     * Sets URL\n     *\n     * @param {String} url - URL\n     */\n    inline.setAnchor = function (url) {\n\n        document.execCommand('createLink', false, url);\n\n        /** Close after URL inserting */\n        editor.toolbar.inline.closeAction();\n\n    };\n\n    /**\n     * @private\n     *\n     * Saves selection\n     */\n    inline.saveSelection = function (containerEl) {\n\n        var range = window.getSelection().getRangeAt(0),\n            preSelectionRange = range.cloneRange(),\n            start;\n\n        preSelectionRange.selectNodeContents(containerEl);\n        preSelectionRange.setEnd(range.startContainer, range.startOffset);\n\n        start = preSelectionRange.toString().length;\n\n        return {\n            start: start,\n            end: start + range.toString().length\n        };\n\n    };\n\n    /**\n     * @private\n     *\n     * Sets to previous selection (Range)\n     *\n     * @param {Element} containerEl - editable element where we restore range\n     * @param {Object} savedSel - range basic information to restore\n     */\n    inline.restoreSelection = function (containerEl, savedSel) {\n\n        var range     = document.createRange(),\n            charIndex = 0;\n\n        range.setStart(containerEl, 0);\n        range.collapse(true);\n\n        var nodeStack = [ containerEl ],\n            node,\n            foundStart = false,\n            stop = false,\n            nextCharIndex;\n\n        while (!stop && (node = nodeStack.pop())) {\n\n            if (node.nodeType == 3) {\n\n                nextCharIndex = charIndex + node.length;\n\n                if (!foundStart && savedSel.start >= charIndex && savedSel.start <= nextCharIndex) {\n\n                    range.setStart(node, savedSel.start - charIndex);\n                    foundStart = true;\n\n                }\n                if (foundStart && savedSel.end >= charIndex && savedSel.end <= nextCharIndex) {\n\n                    range.setEnd(node, savedSel.end - charIndex);\n                    stop = true;\n\n                }\n                charIndex = nextCharIndex;\n\n            } else {\n\n                var i = node.childNodes.length;\n\n                while (i--) {\n\n                    nodeStack.push(node.childNodes[i]);\n\n                }\n\n            }\n\n        }\n\n        var sel = window.getSelection();\n\n        sel.removeAllRanges();\n        sel.addRange(range);\n\n    };\n\n    /**\n     * @private\n     *\n     * Removes all ranges from window selection\n     */\n    inline.clearRange = function () {\n\n        var selection = window.getSelection();\n\n        selection.removeAllRanges();\n\n    };\n\n    /**\n     * @private\n     *\n     * sets or removes hightlight\n     */\n    inline.hightlight = function (tool) {\n\n        var dataType = tool.dataset.type;\n\n        if (document.queryCommandState(dataType)) {\n\n            editor.toolbar.inline.setButtonHighlighted(tool);\n\n        } else {\n\n            editor.toolbar.inline.removeButtonsHighLight(tool);\n\n        }\n\n        /**\n         *\n         * hightlight for anchors\n         */\n        var selection = window.getSelection(),\n            tag = selection.anchorNode.parentNode;\n\n        if (tag.tagName == 'A' && dataType == 'link') {\n\n            editor.toolbar.inline.setButtonHighlighted(tool);\n\n        }\n\n    };\n\n    /**\n     * @private\n     *\n     * Mark button if text is already executed\n     */\n    inline.setButtonHighlighted = function (button) {\n\n        button.classList.add('hightlighted');\n\n        /** At link tool we also change icon */\n        if (button.dataset.type == 'link') {\n\n            var icon = button.childNodes[0];\n\n            icon.classList.remove('ce-icon-link');\n            icon.classList.add('ce-icon-unlink');\n\n        }\n\n    };\n\n    /**\n     * @private\n     *\n     * Removes hightlight\n     */\n    inline.removeButtonsHighLight = function (button) {\n\n        button.classList.remove('hightlighted');\n\n        /** At link tool we also change icon */\n        if (button.dataset.type == 'link') {\n\n            var icon = button.childNodes[0];\n\n            icon.classList.remove('ce-icon-unlink');\n            icon.classList.add('ce-icon-link');\n\n        }\n\n    };\n\n\n    return inline;\n\n})({});\n\n\n// WEBPACK FOOTER //\n// ./modules/toolbar/inline.js","/**\n * Codex Editor toolbox\n *\n * All tools be able to appended here\n *\n * @author Codex Team\n * @version 1.0\n */\n\nlet editor = codex.editor;\n\nmodule.exports = (function (toolbox) {\n\n    toolbox.opened = false;\n\n    /** Shows toolbox */\n    toolbox.open = function () {\n\n        /** Close setting if toolbox is opened */\n        if (editor.toolbar.settings.opened) {\n\n            editor.toolbar.settings.close();\n\n        }\n\n        /** display toolbox */\n        editor.nodes.toolbox.classList.add('opened');\n\n        /** Animate plus button */\n        editor.nodes.plusButton.classList.add('clicked');\n\n        /** toolbox state */\n        editor.toolbar.toolbox.opened = true;\n\n    };\n\n    /** Closes toolbox */\n    toolbox.close = function () {\n\n        /** Makes toolbox disapear */\n        editor.nodes.toolbox.classList.remove('opened');\n\n        /** Rotate plus button */\n        editor.nodes.plusButton.classList.remove('clicked');\n\n        /** toolbox state */\n        editor.toolbar.toolbox.opened = false;\n\n    };\n\n    toolbox.leaf = function () {\n\n        let currentTool = editor.toolbar.current,\n            tools       = Object.keys(editor.tools),\n            barButtons  = editor.nodes.toolbarButtons,\n            nextToolIndex = 0,\n            toolToSelect,\n            visibleTool,\n            tool;\n\n        if ( !currentTool ) {\n\n            /** Get first tool from object*/\n            for(tool in editor.tools) {\n\n                if (editor.tools[tool].displayInToolbox) {\n\n                    break;\n\n                }\n\n                nextToolIndex ++;\n\n            }\n\n        } else {\n\n            nextToolIndex = tools.indexOf(currentTool) + 1;\n            visibleTool = tools[nextToolIndex];\n\n            while (!editor.tools[visibleTool].displayInToolbox) {\n\n                nextToolIndex++;\n                visibleTool = tools[nextToolIndex];\n\n                if ( nextToolIndex == tools.length ) {\n\n                    nextToolIndex = 0;\n                    visibleTool = tools[nextToolIndex];\n\n                }\n\n            }\n\n        }\n\n        toolToSelect = tools[nextToolIndex];\n\n        for ( var button in barButtons ) {\n\n            barButtons[button].classList.remove('selected');\n\n        }\n\n        barButtons[toolToSelect].classList.add('selected');\n        editor.toolbar.current = toolToSelect;\n\n    };\n\n    /**\n     * Transforming selected node type into selected toolbar element type\n     * @param {event} event\n     */\n    toolbox.toolClicked = function (event) {\n\n        /**\n         * UNREPLACEBLE_TOOLS this types of tools are forbidden to replace even they are empty\n         */\n        var UNREPLACEBLE_TOOLS = ['image', 'link', 'list', 'instagram', 'twitter', 'embed'],\n            tool               = editor.tools[editor.toolbar.current],\n            workingNode        = editor.content.currentNode,\n            currentInputIndex  = editor.caret.inputIndex,\n            newBlockContent,\n            appendCallback,\n            blockData;\n\n        /** Make block from plugin */\n        newBlockContent = tool.render();\n\n        /** information about block */\n        blockData = {\n            block     : newBlockContent,\n            type      : tool.type,\n            stretched : false\n        };\n\n        if (\n            workingNode &&\n            UNREPLACEBLE_TOOLS.indexOf(workingNode.dataset.tool) === -1 &&\n            workingNode.textContent.trim() === ''\n        ) {\n\n            /** Replace current block */\n            editor.content.switchBlock(workingNode, newBlockContent, tool.type);\n\n        } else {\n\n            /** Insert new Block from plugin */\n            editor.content.insertBlock(blockData);\n\n            /** increase input index */\n            currentInputIndex++;\n\n        }\n\n        /** Fire tool append callback  */\n        appendCallback = tool.appendCallback;\n\n        if (appendCallback && typeof appendCallback == 'function') {\n\n            appendCallback.call(event);\n\n        }\n\n        window.setTimeout(function () {\n\n            /** Set caret to current block */\n            editor.caret.setToBlock(currentInputIndex);\n\n        }, 10);\n\n\n        /**\n         * Changing current Node\n         */\n        editor.content.workingNodeChanged();\n\n        /**\n         * Move toolbar when node is changed\n         */\n        editor.toolbar.move();\n\n    };\n\n    return toolbox;\n\n})({});\n\n\n// WEBPACK FOOTER //\n// ./modules/toolbar/toolbox.js","/**\n * Codex Editor callbacks module\n *\n * @author Codex Team\n * @version 1.3.7\n */\nlet editor = codex.editor;\n\nmodule.exports = (function (callbacks) {\n\n    callbacks.globalKeydown = function (event) {\n\n        switch (event.keyCode) {\n            case editor.core.keys.ENTER : editor.callback.enterKeyPressed(event);     break;\n        }\n\n    };\n\n    callbacks.redactorKeyDown = function (event) {\n\n        switch (event.keyCode) {\n            case editor.core.keys.TAB   : editor.callback.tabKeyPressed(event);                     break;\n            case editor.core.keys.ENTER : editor.callback.enterKeyPressedOnRedactorZone(event);     break;\n            case editor.core.keys.ESC   : editor.callback.escapeKeyPressed(event);                  break;\n            default                    : editor.callback.defaultKeyPressed(event);                 break;\n        }\n\n    };\n\n    callbacks.globalKeyup = function (event) {\n\n        switch (event.keyCode) {\n            case editor.core.keys.UP    :\n            case editor.core.keys.LEFT  :\n            case editor.core.keys.RIGHT :\n            case editor.core.keys.DOWN  : editor.callback.arrowKeyPressed(event); break;\n        }\n\n    };\n\n    callbacks.tabKeyPressed = function (event) {\n\n        if ( !editor.toolbar.opened ) {\n\n            editor.toolbar.open();\n\n        }\n\n        if (editor.toolbar.opened && !editor.toolbar.toolbox.opened) {\n\n            editor.toolbar.toolbox.open();\n\n        } else {\n\n            editor.toolbar.toolbox.leaf();\n\n        }\n\n        event.preventDefault();\n\n    };\n\n    /**\n    * @param {Event} event\n    */\n    callbacks.enterKeyPressed = function () {\n\n        if (editor.content.editorAreaHightlighted) {\n\n            /**\n             * it means that we lose input index, saved index before is not correct\n             * therefore we need to set caret when we insert new block\n             */\n            editor.caret.inputIndex = -1;\n\n            editor.callback.enterPressedOnBlock();\n\n        }\n\n    };\n\n    /**\n     * ENTER key handler\n     * Makes new paragraph block\n     */\n    callbacks.enterKeyPressedOnRedactorZone = function (event) {\n\n        if (event.target.contentEditable == 'true') {\n\n            /** Update input index */\n            editor.caret.saveCurrentInputIndex();\n\n        }\n\n        var currentInputIndex       = editor.caret.getCurrentInputIndex() || 0,\n            workingNode             = editor.content.currentNode,\n            tool                    = workingNode.dataset.tool,\n            isEnterPressedOnToolbar = editor.toolbar.opened &&\n                                        editor.toolbar.current &&\n                                        event.target == editor.state.inputs[currentInputIndex];\n\n        /** The list of tools which needs the default browser behaviour */\n        var enableLineBreaks = editor.tools[tool].enableLineBreaks;\n\n        /** This type of block creates when enter is pressed */\n        var NEW_BLOCK_TYPE = editor.settings.initialBlockPlugin;\n\n        /**\n         * When toolbar is opened, select tool instead of making new paragraph\n         */\n        if ( isEnterPressedOnToolbar ) {\n\n            event.preventDefault();\n\n            editor.toolbar.toolbox.toolClicked(event);\n\n            editor.toolbar.close();\n\n            /**\n             * Stop other listeners callback executions\n             */\n            event.stopPropagation();\n            event.stopImmediatePropagation();\n\n            return;\n\n        }\n\n        /**\n         * Allow paragraph lineBreaks with shift enter\n         * Or if shiftkey pressed and enter and enabledLineBreaks, the let new block creation\n         */\n        if ( event.shiftKey || enableLineBreaks ) {\n\n            event.stopPropagation();\n            event.stopImmediatePropagation();\n            return;\n\n        }\n\n        var currentSelection = window.getSelection(),\n            currentSelectedNode = currentSelection.anchorNode,\n            caretAtTheEndOfText = editor.caret.position.atTheEnd(),\n            isTextNodeHasParentBetweenContenteditable = false;\n\n        /**\n         * Allow making new <p> in same block by SHIFT+ENTER and forbids to prevent default browser behaviour\n         */\n        if ( event.shiftKey && !enableLineBreaks ) {\n\n            editor.callback.enterPressedOnBlock(editor.content.currentBlock, event);\n            event.preventDefault();\n            return;\n\n        }\n\n        /**\n         * Workaround situation when caret at the Text node that has some wrapper Elements\n         * Split block cant handle this.\n         * We need to save default behavior\n         */\n        isTextNodeHasParentBetweenContenteditable = currentSelectedNode && currentSelectedNode.parentNode.contentEditable != 'true';\n\n        /**\n         * Split blocks when input has several nodes and caret placed in textNode\n         */\n        if (\n            currentSelectedNode.nodeType == editor.core.nodeTypes.TEXT &&\n            !isTextNodeHasParentBetweenContenteditable &&\n            !caretAtTheEndOfText\n        ) {\n\n            event.preventDefault();\n\n            editor.core.log('Splitting Text node...');\n\n            editor.content.splitBlock(currentInputIndex);\n\n            /** Show plus button when next input after split is empty*/\n            if (!editor.state.inputs[currentInputIndex + 1].textContent.trim()) {\n\n                editor.toolbar.showPlusButton();\n\n            }\n\n        } else {\n\n            var islastNode = editor.content.isLastNode(currentSelectedNode);\n\n            if ( islastNode && caretAtTheEndOfText ) {\n\n                event.preventDefault();\n                event.stopPropagation();\n                event.stopImmediatePropagation();\n\n                editor.core.log('ENTER clicked in last textNode. Create new BLOCK');\n\n                editor.content.insertBlock({\n                    type: NEW_BLOCK_TYPE,\n                    block: editor.tools[NEW_BLOCK_TYPE].render()\n                }, true);\n\n                editor.toolbar.move();\n                editor.toolbar.open();\n\n                /** Show plus button with empty block */\n                editor.toolbar.showPlusButton();\n\n            }\n\n        }\n\n        /** get all inputs after new appending block */\n        editor.ui.saveInputs();\n\n    };\n\n    callbacks.escapeKeyPressed = function (event) {\n\n        /** Close all toolbar */\n        editor.toolbar.close();\n\n        /** Close toolbox */\n        editor.toolbar.toolbox.close();\n\n        event.preventDefault();\n\n    };\n\n    /**\n    * @param {Event} event\n    */\n    callbacks.arrowKeyPressed = function () {\n\n        editor.content.workingNodeChanged();\n\n        /* Closing toolbar */\n        editor.toolbar.close();\n        editor.toolbar.move();\n\n    };\n\n    /**\n    * @param {Event} event\n    */\n    callbacks.defaultKeyPressed = function () {\n\n        editor.toolbar.close();\n\n        if (!editor.toolbar.inline.actionsOpened) {\n\n            editor.toolbar.inline.close();\n            editor.content.clearMark();\n\n        }\n\n    };\n\n    callbacks.redactorClicked = function (event) {\n\n        callbacks.detectWhenClickedOnFirstLevelBlockArea();\n\n        editor.content.workingNodeChanged(event.target);\n\n        editor.ui.saveInputs();\n\n        var selectedText = editor.toolbar.inline.getSelectionText(),\n            firstLevelBlock;\n\n        /**\n         * If selection range took off, then we hide inline toolbar\n         */\n        if (selectedText.length === 0) {\n\n            editor.toolbar.inline.close();\n\n        }\n\n        /** Update current input index in memory when caret focused into existed input */\n        if (event.target.contentEditable == 'true') {\n\n            editor.caret.saveCurrentInputIndex();\n\n        }\n\n        if (editor.content.currentNode === null) {\n\n            /**\n             * If inputs in redactor does not exits, then we put input index 0 not -1\n             */\n            var indexOfLastInput = editor.state.inputs.length > 0 ? editor.state.inputs.length - 1 : 0;\n\n            /** If we have any inputs */\n            if (editor.state.inputs.length) {\n\n                /**\n                * @todo Refactor\n                */\n\n                /** getting firstlevel parent of input */\n                firstLevelBlock = editor.content.getFirstLevelBlock(editor.state.inputs[indexOfLastInput]);\n\n            }\n\n            /** If input is empty, then we set caret to the last input */\n            if (editor.state.inputs.length && editor.state.inputs[indexOfLastInput].textContent === '' && firstLevelBlock.dataset.tool == editor.settings.initialBlockPlugin) {\n\n                editor.caret.setToBlock(indexOfLastInput);\n\n            } else {\n\n                /** Create new input when caret clicked in redactors area */\n                var NEW_BLOCK_TYPE = editor.settings.initialBlockPlugin;\n\n                editor.content.insertBlock({\n                    type  : NEW_BLOCK_TYPE,\n                    block : editor.tools[NEW_BLOCK_TYPE].render()\n                });\n\n                /** If there is no inputs except inserted */\n                if (editor.state.inputs.length === 1) {\n\n                    editor.caret.setToBlock(indexOfLastInput);\n\n                } else {\n\n                    /** Set caret to this appended input */\n                    editor.caret.setToNextBlock(indexOfLastInput);\n\n                }\n\n            }\n\n            /**\n             * Move toolbar to the right position and open\n             */\n            editor.toolbar.move();\n            editor.toolbar.open();\n\n        } else {\n\n            /**\n             * Move toolbar to the new position and open\n             */\n            editor.toolbar.move();\n            editor.toolbar.open();\n\n            /** Close all panels */\n            editor.toolbar.settings.close();\n            editor.toolbar.toolbox.close();\n\n        }\n\n\n        var inputIsEmpty = !editor.content.currentNode.textContent.trim(),\n            currentNodeType = editor.content.currentNode.dataset.tool,\n            isInitialType = currentNodeType == editor.settings.initialBlockPlugin;\n\n\n        /** Hide plus buttons */\n        editor.toolbar.hidePlusButton();\n\n        /** Mark current block */\n        editor.content.markBlock();\n\n\n        if ( isInitialType && inputIsEmpty ) {\n\n            /** Show plus button */\n            editor.toolbar.showPlusButton();\n\n        }\n\n\n    };\n\n    /**\n     * This method allows to define, is caret in contenteditable element or not.\n     * Otherwise, if we get TEXT node from range container, that will means we have input index.\n     * In this case we use default browsers behaviour (if plugin allows that) or overwritten action.\n     * Therefore, to be sure that we've clicked first-level block area, we should have currentNode, which always\n     * specifies to the first-level block. Other cases we just ignore.\n     */\n    callbacks.detectWhenClickedOnFirstLevelBlockArea = function () {\n\n        var selection  = window.getSelection(),\n            anchorNode = selection.anchorNode,\n            flag = false;\n\n        if (selection.rangeCount === 0) {\n\n            editor.content.editorAreaHightlighted = true;\n\n        } else {\n\n            if (!editor.core.isDomNode(anchorNode)) {\n\n                anchorNode = anchorNode.parentNode;\n\n            }\n\n            /** Already founded, without loop */\n            if (anchorNode.contentEditable == 'true') {\n\n                flag = true;\n\n            }\n\n            while (anchorNode.contentEditable != 'true') {\n\n                anchorNode = anchorNode.parentNode;\n\n                if (anchorNode.contentEditable == 'true') {\n\n                    flag = true;\n\n                }\n\n                if (anchorNode == document.body) {\n\n                    break;\n\n                }\n\n            }\n\n            /** If editable element founded, flag is \"TRUE\", Therefore we return \"FALSE\" */\n            editor.content.editorAreaHightlighted = flag ? false : true;\n\n        }\n\n    };\n\n    /**\n     * Toolbar button click handler\n     * @param this - cursor to the button\n     */\n    callbacks.toolbarButtonClicked = function (event) {\n\n        var button = this;\n\n        editor.toolbar.current = button.dataset.type;\n\n        editor.toolbar.toolbox.toolClicked(event);\n        editor.toolbar.close();\n\n    };\n\n    /** Show or Hide toolbox when plus button is clicked */\n    callbacks.plusButtonClicked = function () {\n\n        if (!editor.nodes.toolbox.classList.contains('opened')) {\n\n            editor.toolbar.toolbox.open();\n\n        } else {\n\n            editor.toolbar.toolbox.close();\n\n        }\n\n    };\n\n    /**\n     * Block handlers for KeyDown events\n     */\n    callbacks.blockKeydown = function (event) {\n\n        let block = this; // event.target input\n\n        switch (event.keyCode) {\n\n            case editor.core.keys.DOWN:\n            case editor.core.keys.RIGHT:\n                editor.callback.blockRightOrDownArrowPressed();\n                break;\n\n            case editor.core.keys.BACKSPACE:\n                editor.callback.backspacePressed(block, event);\n                break;\n\n            case editor.core.keys.UP:\n            case editor.core.keys.LEFT:\n                editor.callback.blockLeftOrUpArrowPressed();\n                break;\n\n        }\n\n    };\n\n    /**\n     * RIGHT or DOWN keydowns on block\n     */\n    callbacks.blockRightOrDownArrowPressed = function () {\n\n        var selection   = window.getSelection(),\n            inputs      = editor.state.inputs,\n            focusedNode = selection.anchorNode,\n            focusedNodeHolder;\n\n        /** Check for caret existance */\n        if (!focusedNode) {\n\n            return false;\n\n        }\n\n        /** Looking for closest (parent) contentEditable element of focused node */\n        while (focusedNode.contentEditable != 'true') {\n\n            focusedNodeHolder = focusedNode.parentNode;\n            focusedNode       = focusedNodeHolder;\n\n        }\n\n        /** Input index in DOM level */\n        var editableElementIndex = 0;\n\n        while (focusedNode != inputs[editableElementIndex]) {\n\n            editableElementIndex ++;\n\n        }\n\n        /**\n         * Founded contentEditable element doesn't have childs\n         * Or maybe New created block\n         */\n        if (!focusedNode.textContent) {\n\n            editor.caret.setToNextBlock(editableElementIndex);\n            return;\n\n        }\n\n        /**\n         * Do nothing when caret doesn not reaches the end of last child\n         */\n        var caretInLastChild    = false,\n            caretAtTheEndOfText = false;\n\n        var lastChild,\n            deepestTextnode;\n\n        lastChild = focusedNode.childNodes[focusedNode.childNodes.length - 1 ];\n\n        if (editor.core.isDomNode(lastChild)) {\n\n            deepestTextnode = editor.content.getDeepestTextNodeFromPosition(lastChild, lastChild.childNodes.length);\n\n        } else {\n\n            deepestTextnode = lastChild;\n\n        }\n\n        caretInLastChild = selection.anchorNode == deepestTextnode;\n        caretAtTheEndOfText = deepestTextnode.length == selection.anchorOffset;\n\n        if ( !caretInLastChild  || !caretAtTheEndOfText ) {\n\n            editor.core.log('arrow [down|right] : caret does not reached the end');\n            return false;\n\n        }\n\n        editor.caret.setToNextBlock(editableElementIndex);\n\n    };\n\n    /**\n     * LEFT or UP keydowns on block\n     */\n    callbacks.blockLeftOrUpArrowPressed = function () {\n\n        var selection   = window.getSelection(),\n            inputs      = editor.state.inputs,\n            focusedNode = selection.anchorNode,\n            focusedNodeHolder;\n\n        /** Check for caret existance */\n        if (!focusedNode) {\n\n            return false;\n\n        }\n\n        /**\n         * LEFT or UP not at the beginning\n         */\n        if ( selection.anchorOffset !== 0) {\n\n            return false;\n\n        }\n\n        /** Looking for parent contentEditable block */\n        while (focusedNode.contentEditable != 'true') {\n\n            focusedNodeHolder = focusedNode.parentNode;\n            focusedNode       = focusedNodeHolder;\n\n        }\n\n        /** Input index in DOM level */\n        var editableElementIndex = 0;\n\n        while (focusedNode != inputs[editableElementIndex]) {\n\n            editableElementIndex ++;\n\n        }\n\n        /**\n         * Do nothing if caret is not at the beginning of first child\n         */\n        var caretInFirstChild   = false,\n            caretAtTheBeginning = false;\n\n        var firstChild,\n            deepestTextnode;\n\n        /**\n         * Founded contentEditable element doesn't have childs\n         * Or maybe New created block\n         */\n        if (!focusedNode.textContent) {\n\n            editor.caret.setToPreviousBlock(editableElementIndex);\n            return;\n\n        }\n\n        firstChild = focusedNode.childNodes[0];\n\n        if (editor.core.isDomNode(firstChild)) {\n\n            deepestTextnode = editor.content.getDeepestTextNodeFromPosition(firstChild, 0);\n\n        } else {\n\n            deepestTextnode = firstChild;\n\n        }\n\n        caretInFirstChild   = selection.anchorNode == deepestTextnode;\n        caretAtTheBeginning = selection.anchorOffset === 0;\n\n        if ( caretInFirstChild && caretAtTheBeginning ) {\n\n            editor.caret.setToPreviousBlock(editableElementIndex);\n\n        }\n\n    };\n\n    /**\n     * Callback for enter key pressing in first-level block area\n     * @param {Event} event\n     */\n    callbacks.enterPressedOnBlock = function () {\n\n        var NEW_BLOCK_TYPE  = editor.settings.initialBlockPlugin;\n\n        editor.content.insertBlock({\n            type  : NEW_BLOCK_TYPE,\n            block : editor.tools[NEW_BLOCK_TYPE].render()\n        }, true );\n\n        editor.toolbar.move();\n        editor.toolbar.open();\n\n    };\n\n    callbacks.backspacePressed = function (block, event) {\n\n        var currentInputIndex = editor.caret.getCurrentInputIndex(),\n            range,\n            selectionLength,\n            firstLevelBlocksCount;\n\n        if (block.textContent.trim()) {\n\n            range           = editor.content.getRange();\n            selectionLength = range.endOffset - range.startOffset;\n\n            if (editor.caret.position.atStart() && !selectionLength && editor.state.inputs[currentInputIndex - 1]) {\n\n                editor.content.mergeBlocks(currentInputIndex);\n\n            } else {\n\n                return;\n\n            }\n\n        }\n\n        if (!selectionLength) {\n\n            block.remove();\n\n        }\n\n\n        firstLevelBlocksCount = editor.nodes.redactor.childNodes.length;\n\n        /**\n         * If all blocks are removed\n         */\n        if (firstLevelBlocksCount === 0) {\n\n            /** update currentNode variable */\n            editor.content.currentNode = null;\n\n            /** Inserting new empty initial block */\n            editor.ui.addInitialBlock();\n\n            /** Updating inputs state after deleting last block */\n            editor.ui.saveInputs();\n\n            /** Set to current appended block */\n            window.setTimeout(function () {\n\n                editor.caret.setToPreviousBlock(1);\n\n            }, 10);\n\n        } else {\n\n            if (editor.caret.inputIndex !== 0) {\n\n                /** Target block is not first */\n                editor.caret.setToPreviousBlock(editor.caret.inputIndex);\n\n            } else {\n\n                /** If we try to delete first block */\n                editor.caret.setToNextBlock(editor.caret.inputIndex);\n\n            }\n\n        }\n\n        editor.toolbar.move();\n\n        if (!editor.toolbar.opened) {\n\n            editor.toolbar.open();\n\n        }\n\n        /** Updating inputs state */\n        editor.ui.saveInputs();\n\n        /** Prevent default browser behaviour */\n        event.preventDefault();\n\n    };\n\n    /**\n     * This method is used to observe pasted dirty data.\n     *\n     * Mutation handlers send to separate observers each mutation (added, changed and so on), which will be\n     * passed from handler that sanitizes and replaces data.\n     *\n     * Probably won't be used\n     *\n     * @deprecated\n     *\n     * @param event\n     * @private\n     */\n    callbacks._blockPasteCallback = function () {\n\n        var currentInputIndex = editor.caret.getCurrentInputIndex();\n\n        /**\n         * create an observer instance\n         */\n        var observer = new MutationObserver(editor.callback.handleMutationsOnPaste);\n\n        /**\n         * configuration of the observer:\n         */\n        var config = {\n            attributes: true,\n            childList: false,\n            characterData: false,\n            subtree : true\n        };\n\n        // pass in the target node, as well as the observer options\n        observer.observe(editor.state.inputs[currentInputIndex], config);\n\n    };\n\n    /**\n     * This method prevents default behaviour.\n     *\n     * We get from clipboard pasted data, sanitize, make a fragment that contains of this sanitized nodes.\n     * Firstly, we need to memorize the caret position. We can do that by getting the range of selection.\n     * After all, we insert clear fragment into caret placed position. Then, we should move the caret to the last node\n     *\n     * @param event\n     */\n    callbacks.blockPasteCallback = function (event) {\n\n        /** Prevent default behaviour */\n        event.preventDefault();\n\n        /** Allow paste when event target is editable */\n        if (event.target.contentEditable != 'true') {\n\n            return;\n\n        }\n\n        /** get html pasted data - dirty data */\n        var data = event.clipboardData.getData('text/html') || event.clipboardData.getData('text/plain');\n\n        /** Temporary DIV that is used to work with childs as arrays item */\n        var div     = editor.draw.node('DIV', '', {}),\n            cleaner = new editor.sanitizer.init(editor.sanitizer.Config.BASIC),\n            cleanData,\n            fragment;\n\n        /** Create fragment, that we paste to range after proccesing */\n        fragment = document.createDocumentFragment();\n\n        cleanData = cleaner.clean(data);\n\n        div.innerHTML = cleanData;\n\n        var node, lastNode;\n\n        /**\n         * and fill in fragment\n         */\n        while (( node = div.firstChild) ) {\n\n            lastNode = fragment.appendChild(node);\n\n        }\n\n        /**\n         * work with selection and range\n         */\n        var selection, range;\n\n        selection = window.getSelection();\n\n        range = selection.getRangeAt(0);\n        range.deleteContents();\n\n        range.insertNode(fragment);\n\n        /** Preserve the selection */\n        if (lastNode) {\n\n            range = range.cloneRange();\n            range.setStartAfter(lastNode);\n            range.collapse(true);\n            selection.removeAllRanges();\n            selection.addRange(range);\n\n        }\n\n    };\n\n    /**\n     * Sends all mutations to paste handler\n     */\n    callbacks.handleMutationsOnPaste = function (mutations) {\n\n        var self = this;\n\n        /**\n         * Calling function with context of this function.\n         * Also, we should sanitize pasted or changed data one time and ignore\n         * changings which makes sanitize method.\n         * For that, we need to send Context, MutationObserver.__proto__ that contains\n         * observer disconnect method.\n         */\n        mutations.forEach(function (mutation) {\n\n            editor.content.paste.call(self, mutation);\n\n        });\n\n    };\n\n    /**\n     * Clicks on block settings button\n     */\n    callbacks.showSettingsButtonClicked = function () {\n\n        /**\n         * Get type of current block\n         * It uses to append settings from tool.settings property.\n         * ...\n         * Type is stored in data-type attribute on block\n         */\n        var currentToolType = editor.content.currentNode.dataset.tool;\n\n        editor.toolbar.settings.toggle(currentToolType);\n\n        /** Close toolbox when settings button is active */\n        editor.toolbar.toolbox.close();\n        editor.toolbar.settings.hideRemoveActions();\n\n    };\n\n    return callbacks;\n\n})({});\n\n\n// WEBPACK FOOTER //\n// ./modules/callbacks.js","/**\n * Codex Editor Draw module\n *\n * @author Codex Team\n * @version 1.0.\n */\n\nmodule.exports = (function (draw) {\n\n    /**\n     * Base editor wrapper\n     */\n    draw.wrapper = function () {\n\n        var wrapper = document.createElement('div');\n\n        wrapper.className += 'codex-editor';\n\n        return wrapper;\n\n    };\n\n    /**\n     * Content-editable holder\n     */\n    draw.redactor = function () {\n\n        var redactor = document.createElement('div');\n\n        redactor.className += 'ce-redactor';\n\n        return redactor;\n\n    };\n\n    draw.ceBlock = function () {\n\n        var block = document.createElement('DIV');\n\n        block.className += 'ce_block';\n\n        return block;\n\n    };\n\n    /**\n     * Empty toolbar with toggler\n     */\n    draw.toolbar = function () {\n\n        var bar = document.createElement('div');\n\n        bar.className += 'ce-toolbar';\n\n        return bar;\n\n    };\n\n    draw.toolbarContent = function () {\n\n        var wrapper = document.createElement('DIV');\n\n        wrapper.classList.add('ce-toolbar__content');\n\n        return wrapper;\n\n    };\n\n    /**\n     * Inline toolbar\n     */\n    draw.inlineToolbar = function () {\n\n        var bar = document.createElement('DIV');\n\n        bar.className += 'ce-toolbar-inline';\n\n        return bar;\n\n    };\n\n    /**\n     * Wrapper for inline toobar buttons\n     */\n    draw.inlineToolbarButtons = function () {\n\n        var wrapper = document.createElement('DIV');\n\n        wrapper.className += 'ce-toolbar-inline__buttons';\n\n        return wrapper;\n\n    };\n\n    /**\n     * For some actions\n     */\n    draw.inlineToolbarActions = function () {\n\n        var wrapper = document.createElement('DIV');\n\n        wrapper.className += 'ce-toolbar-inline__actions';\n\n        return wrapper;\n\n    };\n\n    draw.inputForLink = function () {\n\n        var input = document.createElement('INPUT');\n\n        input.type        = 'input';\n        input.className  += 'inputForLink';\n        input.placeholder = '  ...';\n        input.setAttribute('form', 'defaultForm');\n\n        input.setAttribute('autofocus', 'autofocus');\n\n        return input;\n\n    };\n\n    /**\n     * Block with notifications\n     */\n    draw.alertsHolder = function () {\n\n        var block = document.createElement('div');\n\n        block.classList.add('ce_notifications-block');\n\n        return block;\n\n    };\n\n    /**\n     * @todo Desc\n     */\n    draw.blockButtons = function () {\n\n        var block = document.createElement('div');\n\n        block.className += 'ce-toolbar__actions';\n\n        return block;\n\n    };\n\n    /**\n     * Block settings panel\n     */\n    draw.blockSettings = function () {\n\n        var settings = document.createElement('div');\n\n        settings.className += 'ce-settings';\n\n        return settings;\n\n    };\n\n    draw.defaultSettings = function () {\n\n        var div = document.createElement('div');\n\n        div.classList.add('ce-settings_default');\n\n        return div;\n\n    };\n\n    draw.pluginsSettings = function () {\n\n        var div = document.createElement('div');\n\n        div.classList.add('ce-settings_plugin');\n\n        return div;\n\n    };\n\n    draw.plusButton = function () {\n\n        var button = document.createElement('span');\n\n        button.className = 'ce-toolbar__plus';\n        // button.innerHTML = '<i class=\"ce-icon-plus\"></i>';\n\n        return button;\n\n    };\n\n    /**\n     * Settings button in toolbar\n     */\n    draw.settingsButton = function () {\n\n        var toggler = document.createElement('span');\n\n        toggler.className = 'ce-toolbar__settings-btn';\n\n        /** Toggler button*/\n        toggler.innerHTML = '<i class=\"ce-icon-cog\"></i>';\n\n        return toggler;\n\n    };\n\n    /**\n     * Redactor tools wrapper\n     */\n\n    draw.toolbox = function () {\n\n        var wrapper = document.createElement('div');\n\n        wrapper.className = 'ce-toolbar__tools';\n\n        return wrapper;\n\n    };\n\n    /**\n     * @protected\n     *\n     * Draws tool buttons for toolbox\n     *\n     * @param {String} type\n     * @param {String} classname\n     * @returns {Element}\n     */\n    draw.toolbarButton = function (type, classname) {\n\n        var button     = document.createElement('li'),\n            toolIcon  = document.createElement('i'),\n            toolTitle = document.createElement('span');\n\n        button.dataset.type = type;\n        button.setAttribute('title', type);\n\n        toolIcon.classList.add(classname);\n        toolTitle.classList.add('ce_toolbar_tools--title');\n\n\n        button.appendChild(toolIcon);\n        button.appendChild(toolTitle);\n\n        return button;\n\n    };\n\n    /**\n     * @protected\n     *\n     * Draws tools for inline toolbar\n     *\n     * @param {String} type\n     * @param {String} classname\n     */\n    draw.toolbarButtonInline = function (type, classname) {\n\n        var button     = document.createElement('BUTTON'),\n            toolIcon  = document.createElement('I');\n\n        button.type = 'button';\n        button.dataset.type = type;\n        toolIcon.classList.add(classname);\n\n        button.appendChild(toolIcon);\n\n        return button;\n\n    };\n\n    /**\n     * Redactor block\n     */\n    draw.block = function (tagName, content) {\n\n        var node = document.createElement(tagName);\n\n        node.innerHTML = content || '';\n\n        return node;\n\n    };\n\n    /**\n     * Creates Node with passed tagName and className\n     * @param {string}  tagName\n     * @param {string} className\n     * @param {object} properties - allow to assign properties\n     */\n    draw.node = function ( tagName, className, properties ) {\n\n        var el = document.createElement( tagName );\n\n        if ( className ) el.className = className;\n\n        if ( properties ) {\n\n            for (var name in properties) {\n\n                el[name] = properties[name];\n\n            }\n\n        }\n\n        return el;\n\n    };\n\n    draw.unavailableBlock = function ( data ) {\n\n        var wrapper = document.createElement('DIV');\n        wrapper.classList.add('unavailableBlock');\n        wrapper.dataset.cacheId = data;\n\n        return wrapper;\n\n    };\n\n    return draw;\n\n})({});\n\n\n// WEBPACK FOOTER //\n// ./modules/draw.js","/**\n * Codex Editor Caret Module\n *\n * @author Codex Team\n * @version 1.0\n */\nlet editor = codex.editor;\n\nmodule.exports = (function (caret) {\n\n    /**\n     * @var {int} InputIndex - editable element in DOM\n     */\n    caret.inputIndex = null;\n\n    /**\n     * @var {int} offset - caret position in a text node.\n     */\n    caret.offset = null;\n\n    /**\n     * @var {int} focusedNodeIndex - we get index of child node from first-level block\n     */\n    caret.focusedNodeIndex = null;\n\n    /**\n     * Creates Document Range and sets caret to the element.\n     * @protected\n     * @uses caret.save  if you need to save caret position\n     * @param {Element} el - Changed Node.\n     */\n    caret.set = function ( el, index, offset) {\n\n        offset = offset || caret.offset || 0;\n        index  = index  || caret.focusedNodeIndex || 0;\n\n        var childs = el.childNodes,\n            nodeToSet;\n\n        if ( childs.length === 0 ) {\n\n            nodeToSet = el;\n\n        } else {\n\n            nodeToSet = childs[index];\n\n        }\n\n        /** If Element is INPUT */\n        if (el.tagName == 'INPUT') {\n\n            el.focus();\n            return;\n\n        }\n\n        if (editor.core.isDomNode(nodeToSet)) {\n\n            nodeToSet = editor.content.getDeepestTextNodeFromPosition(nodeToSet, nodeToSet.childNodes.length);\n\n        }\n\n        var range     = document.createRange(),\n            selection = window.getSelection();\n\n        window.setTimeout(function () {\n\n            range.setStart(nodeToSet, offset);\n            range.setEnd(nodeToSet, offset);\n\n            selection.removeAllRanges();\n            selection.addRange(range);\n\n            editor.caret.saveCurrentInputIndex();\n\n        }, 20);\n\n    };\n\n    /**\n     * @protected\n     * Updates index of input and saves it in caret object\n     */\n    caret.saveCurrentInputIndex = function () {\n\n        /** Index of Input that we paste sanitized content */\n        var selection   = window.getSelection(),\n            inputs      = editor.state.inputs,\n            focusedNode = selection.anchorNode,\n            focusedNodeHolder;\n\n        if (!focusedNode) {\n\n            return;\n\n        }\n\n        /** Looking for parent contentEditable block */\n        while (focusedNode.contentEditable != 'true') {\n\n            focusedNodeHolder = focusedNode.parentNode;\n            focusedNode       = focusedNodeHolder;\n\n        }\n\n        /** Input index in DOM level */\n        var editableElementIndex = 0;\n\n        while (focusedNode != inputs[editableElementIndex]) {\n\n            editableElementIndex ++;\n\n        }\n\n        caret.inputIndex = editableElementIndex;\n\n    };\n\n    /**\n     * Returns current input index (caret object)\n     */\n    caret.getCurrentInputIndex = function () {\n\n        return caret.inputIndex;\n\n    };\n\n    /**\n     * @param {int} index - index of first-level block after that we set caret into next input\n     */\n    caret.setToNextBlock = function (index) {\n\n        var inputs = editor.state.inputs,\n            nextInput = inputs[index + 1];\n\n        if (!nextInput) {\n\n            editor.core.log('We are reached the end');\n            return;\n\n        }\n\n        /**\n         * When new Block created or deleted content of input\n         * We should add some text node to set caret\n         */\n        if (!nextInput.childNodes.length) {\n\n            var emptyTextElement = document.createTextNode('');\n\n            nextInput.appendChild(emptyTextElement);\n\n        }\n\n        editor.caret.inputIndex = index + 1;\n        editor.caret.set(nextInput, 0, 0);\n        editor.content.workingNodeChanged(nextInput);\n\n    };\n\n    /**\n     * @param {int} index - index of target input.\n     * Sets caret to input with this index\n     */\n    caret.setToBlock = function (index) {\n\n        var inputs = editor.state.inputs,\n            targetInput = inputs[index];\n\n        if ( !targetInput ) {\n\n            return;\n\n        }\n\n        /**\n         * When new Block created or deleted content of input\n         * We should add some text node to set caret\n         */\n        if (!targetInput.childNodes.length) {\n\n            var emptyTextElement = document.createTextNode('');\n\n            targetInput.appendChild(emptyTextElement);\n\n        }\n\n        editor.caret.inputIndex = index;\n        editor.caret.set(targetInput, 0, 0);\n        editor.content.workingNodeChanged(targetInput);\n\n    };\n\n    /**\n     * @param {int} index - index of input\n     */\n    caret.setToPreviousBlock = function (index) {\n\n        index = index || 0;\n\n        var inputs = editor.state.inputs,\n            previousInput = inputs[index - 1],\n            lastChildNode,\n            lengthOfLastChildNode,\n            emptyTextElement;\n\n\n        if (!previousInput) {\n\n            editor.core.log('We are reached first node');\n            return;\n\n        }\n\n        lastChildNode = editor.content.getDeepestTextNodeFromPosition(previousInput, previousInput.childNodes.length);\n        lengthOfLastChildNode = lastChildNode.length;\n\n        /**\n         * When new Block created or deleted content of input\n         * We should add some text node to set caret\n         */\n        if (!previousInput.childNodes.length) {\n\n            emptyTextElement = document.createTextNode('');\n            previousInput.appendChild(emptyTextElement);\n\n        }\n        editor.caret.inputIndex = index - 1;\n        editor.caret.set(previousInput, previousInput.childNodes.length - 1, lengthOfLastChildNode);\n        editor.content.workingNodeChanged(inputs[index - 1]);\n\n    };\n\n    caret.position = {\n\n        atStart : function () {\n\n            var selection       = window.getSelection(),\n                anchorOffset    = selection.anchorOffset,\n                anchorNode      = selection.anchorNode,\n                firstLevelBlock = editor.content.getFirstLevelBlock(anchorNode),\n                pluginsRender   = firstLevelBlock.childNodes[0];\n\n            if (!editor.core.isDomNode(anchorNode)) {\n\n                anchorNode = anchorNode.parentNode;\n\n            }\n\n            var isFirstNode  = anchorNode === pluginsRender.childNodes[0],\n                isOffsetZero = anchorOffset === 0;\n\n            return isFirstNode && isOffsetZero;\n\n        },\n\n        atTheEnd : function () {\n\n            var selection    = window.getSelection(),\n                anchorOffset = selection.anchorOffset,\n                anchorNode   = selection.anchorNode;\n\n            /** Caret is at the end of input */\n            return !anchorNode || !anchorNode.length || anchorOffset === anchorNode.length;\n\n        }\n    };\n\n    return caret;\n\n})({});\n\n\n// WEBPACK FOOTER //\n// ./modules/caret.js","/**\n * Codex Editor Notification Module\n *\n * @author Codex Team\n * @version 1.0\n */\nlet editor = codex.editor;\n\nmodule.exports = (function (notifications) {\n\n    /**\n     * Error notificator. Shows block with message\n     * @protected\n     */\n    notifications.errorThrown = function (errorMsg, event) {\n\n        editor.notifications.send('This action is not available currently', event.type, false);\n\n    };\n\n    /**\n     * Appends notification with different types\n     * @param message {string} - Error or alert message\n     * @param type {string} - Type of message notification. Ex: Error, Warning, Danger ...\n     * @param append {boolean} - can be True or False when notification should be inserted after\n     */\n    notifications.send = function (message, type, append) {\n\n        var notification = editor.draw.block('div');\n\n        notification.textContent = message;\n        notification.classList.add('ce_notification-item', 'ce_notification-' + type, 'flipInX');\n\n        if (!append) {\n\n            editor.nodes.notifications.innerHTML = '';\n\n        }\n\n        editor.nodes.notifications.appendChild(notification);\n\n        window.setTimeout(function () {\n\n            notification.remove();\n\n        }, 3000);\n\n    };\n\n    return notifications;\n\n})({});\n\n\n// WEBPACK FOOTER //\n// ./modules/notifications.js","/**\n * Codex Editor Parser Module\n *\n * @author Codex Team\n * @version 1.1\n */\nlet editor = codex.editor;\n\nmodule.exports = (function (parser) {\n\n    /** inserting text */\n    parser.insertPastedContent = function (blockType, tag) {\n\n        editor.content.insertBlock({\n            type :  blockType.type,\n            block : blockType.render({\n                text : tag.innerHTML\n            })\n        });\n\n    };\n\n    /**\n     * Check DOM node for display style: separated block or child-view\n     */\n    parser.isFirstLevelBlock = function (node) {\n\n        return node.nodeType == editor.core.nodeTypes.TAG &&\n            node.classList.contains(editor.ui.className.BLOCK_CLASSNAME);\n\n    };\n\n    return parser;\n\n})({});\n\n\n\n// WEBPACK FOOTER //\n// ./modules/parser.js","/**\n * Codex Sanitizer\n */\n\nvar janitor = require('html-janitor');\n\nmodule.exports = (function (sanitizer) {\n\n    /**\n     * Basic config\n     */\n    var Config = {\n\n        BASIC : {\n\n            tags: {\n                p: {},\n                a: {\n                    href: true,\n                    target: '_blank',\n                    rel: 'nofollow'\n                },\n                i: {},\n                b: {},\n                strong: {},\n                em: {},\n                span: {}\n            }\n        }\n    };\n\n    sanitizer.Config = Config;\n\n    sanitizer.init = janitor;\n\n    return sanitizer;\n\n})({});\n\n\n// WEBPACK FOOTER //\n// ./modules/sanitizer.js","(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define('html-janitor', factory);\n  } else if (typeof exports === 'object') {\n    module.exports = factory();\n  } else {\n    root.HTMLJanitor = factory();\n  }\n}(this, function () {\n\n  /**\n   * @param {Object} config.tags Dictionary of allowed tags.\n   * @param {boolean} config.keepNestedBlockElements Default false.\n   */\n  function HTMLJanitor(config) {\n\n    var tagDefinitions = config['tags'];\n    var tags = Object.keys(tagDefinitions);\n\n    var validConfigValues = tags\n      .map(function(k) { return typeof tagDefinitions[k]; })\n      .every(function(type) { return type === 'object' || type === 'boolean' || type === 'function'; });\n\n    if(!validConfigValues) {\n      throw new Error(\"The configuration was invalid\");\n    }\n\n    this.config = config;\n  }\n\n  // TODO: not exhaustive?\n  var blockElementNames = ['P', 'LI', 'TD', 'TH', 'DIV', 'H1', 'H2', 'H3', 'H4', 'H5', 'H6', 'PRE'];\n  function isBlockElement(node) {\n    return blockElementNames.indexOf(node.nodeName) !== -1;\n  }\n\n  var inlineElementNames = ['A', 'B', 'STRONG', 'I', 'EM', 'SUB', 'SUP', 'U', 'STRIKE'];\n  function isInlineElement(node) {\n    return inlineElementNames.indexOf(node.nodeName) !== -1;\n  }\n\n  HTMLJanitor.prototype.clean = function (html) {\n    var sandbox = document.createElement('div');\n    sandbox.innerHTML = html;\n\n    this._sanitize(sandbox);\n\n    return sandbox.innerHTML;\n  };\n\n  HTMLJanitor.prototype._sanitize = function (parentNode) {\n    var treeWalker = createTreeWalker(parentNode);\n    var node = treeWalker.firstChild();\n    if (!node) { return; }\n\n    do {\n      // Ignore nodes that have already been sanitized\n      if (node._sanitized) {\n        continue;\n      }\n\n      if (node.nodeType === Node.TEXT_NODE) {\n        // If this text node is just whitespace and the previous or next element\n        // sibling is a block element, remove it\n        // N.B.: This heuristic could change. Very specific to a bug with\n        // `contenteditable` in Firefox: http://jsbin.com/EyuKase/1/edit?js,output\n        // FIXME: make this an option?\n        if (node.data.trim() === ''\n            && ((node.previousElementSibling && isBlockElement(node.previousElementSibling))\n                 || (node.nextElementSibling && isBlockElement(node.nextElementSibling)))) {\n          parentNode.removeChild(node);\n          this._sanitize(parentNode);\n          break;\n        } else {\n          continue;\n        }\n      }\n\n      // Remove all comments\n      if (node.nodeType === Node.COMMENT_NODE) {\n        parentNode.removeChild(node);\n        this._sanitize(parentNode);\n        break;\n      }\n\n      var isInline = isInlineElement(node);\n      var containsBlockElement;\n      if (isInline) {\n        containsBlockElement = Array.prototype.some.call(node.childNodes, isBlockElement);\n      }\n\n      // Block elements should not be nested (e.g. <li><p>...); if\n      // they are, we want to unwrap the inner block element.\n      var isNotTopContainer = !! parentNode.parentNode;\n      var isNestedBlockElement =\n            isBlockElement(parentNode) &&\n            isBlockElement(node) &&\n            isNotTopContainer;\n\n      var nodeName = node.nodeName.toLowerCase();\n\n      var allowedAttrs = getAllowedAttrs(this.config, nodeName, node);\n\n      var isInvalid = isInline && containsBlockElement;\n\n      // Drop tag entirely according to the whitelist *and* if the markup\n      // is invalid.\n      if (isInvalid || shouldRejectNode(node, allowedAttrs)\n          || (!this.config.keepNestedBlockElements && isNestedBlockElement)) {\n        // Do not keep the inner text of SCRIPT/STYLE elements.\n        if (! (node.nodeName === 'SCRIPT' || node.nodeName === 'STYLE')) {\n          while (node.childNodes.length > 0) {\n            parentNode.insertBefore(node.childNodes[0], node);\n          }\n        }\n        parentNode.removeChild(node);\n\n        this._sanitize(parentNode);\n        break;\n      }\n\n      // Sanitize attributes\n      for (var a = 0; a < node.attributes.length; a += 1) {\n        var attr = node.attributes[a];\n\n        if (shouldRejectAttr(attr, allowedAttrs, node)) {\n          node.removeAttribute(attr.name);\n          // Shift the array to continue looping.\n          a = a - 1;\n        }\n      }\n\n      // Sanitize children\n      this._sanitize(node);\n\n      // Mark node as sanitized so it's ignored in future runs\n      node._sanitized = true;\n    } while ((node = treeWalker.nextSibling()));\n  };\n\n  function createTreeWalker(node) {\n    return document.createTreeWalker(node,\n                                     NodeFilter.SHOW_TEXT | NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_COMMENT,\n                                     null, false);\n  }\n\n  function getAllowedAttrs(config, nodeName, node){\n    if (typeof config.tags[nodeName] === 'function') {\n      return config.tags[nodeName](node);\n    } else {\n      return config.tags[nodeName];\n    }\n  }\n\n  function shouldRejectNode(node, allowedAttrs){\n    if (typeof allowedAttrs === 'undefined') {\n      return true;\n    } else if (typeof allowedAttrs === 'boolean') {\n      return !allowedAttrs;\n    }\n\n    return false;\n  }\n\n  function shouldRejectAttr(attr, allowedAttrs, node){\n    var attrName = attr.name.toLowerCase();\n\n    if (allowedAttrs === true){\n      return false;\n    } else if (typeof allowedAttrs[attrName] === 'function'){\n      return !allowedAttrs[attrName](attr.value, node);\n    } else if (typeof allowedAttrs[attrName] === 'undefined'){\n      return true;\n    } else if (allowedAttrs[attrName] === false) {\n      return true;\n    } else if (typeof allowedAttrs[attrName] === 'string') {\n      return (allowedAttrs[attrName] !== attr.value);\n    }\n\n    return false;\n  }\n\n  return HTMLJanitor;\n\n}));\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/html-janitor/src/html-janitor.js\n// module id = 17\n// module chunks = 0"],"sourceRoot":""}